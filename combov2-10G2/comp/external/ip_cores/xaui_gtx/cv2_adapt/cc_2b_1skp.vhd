-- ----------------------------------------------------------------------------
--    ____  ____
--   /   /\/   /
--  /___/  \  /    Vendor: Xilinx
--  \   \   \/     Version : 1.6
--   \   \         Application : Xilinx GTX Wizard
--   /   /         Filename : CC_2B_1SKP.vhd
--  /___/   /\
--  \   \  /  \
--   \___\/\___\
--
--
--  Module CC_2B_1SKP
--  Generated by Xilinx RocketIO GTX Wizard
--
--  (c) Copyright 2009 Xilinx, Inc. All rights reserved.
--
--  This file contains confidential and proprietary information
--  of Xilinx, Inc. and is protected under U.S. and
--  international copyright and other intellectual property
--  laws.
--
--  DISCLAIMER
--  This disclaimer is not a license and does not grant any
--  rights to the materials distributed herewith. Except as
--  otherwise provided in a valid license issued to you by
--  Xilinx, and to the maximum extent permitted by applicable
--  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
--  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
--  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
--  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
--  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
--  (2) Xilinx shall not be liable (whether in contract or tort,
--  including negligence, or under any other theory of,
--  liability) for any loss or damage of any kind or nature
--  related to, arising under or in connection with these
--  materials, including for any direct, or any indirect,
--  special, incidental, or consequential loss or damage
--  (including loss of data, profits, goodwill, or any type of
--  loss or damage suffered as a result of any action brought
--  by a third party) even if such damage or loss was
--  reasonably foreseeable or Xilinx had been advised of the
--  possibility of the same.
--
--  CRITICAL APPLICATIONS
--  Xilinx products are not designed or intended to be fail-
--  safe, or for use in any application requiring fail-safe
--  performance, such as life-support or safety devices or
--  systems, Class III medical devices, nuclear facilities,
--  applications related to the deployment of airbags, or any
--  other applications that could lead to death, personal
--  injury, or severe property or environmental damage
--  (individually and collectively, "Critical
--  Applications"). Customer assumes the sole risk and
--  liability of any use of Xilinx products in Critical
--  Applications, subject only to applicable laws and
--  regulations governing limitations on product liability.
--
--  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
--  PART OF THIS FILE AT ALL TIMES.
--
------------------------------------------------------------------------------
--  CC_2B_1SKP
--
--
--
--  Description: This module performs clock correction in the FPGA
--               fabric instead of depending on the Virtex-5 GTX built-in
--               clock correction capability.
--
--               * Supports a 2-byte data width / 1-byte CC character
--
------------------------------------------------------------------------------

--`timescale 1 ns / 10 ps

library IEEE;
    use IEEE.std_logic_1164.all;
    use IEEE.std_logic_textio.all;
    use IEEE.Std_logic_unsigned.all;
    use IEEE.numeric_std.all;
library UNISIM;
    use UNISIM.VCOMPONENTS.ALL;

---entity declarations--------------
entity CC_2B_1SKP is
    generic (
         CC_CHAR                   : in  std_logic_vector(7 downto 0) := X"1C";
         ALIGN_CHAR                : in  std_logic_vector(7 downto 0) := X"7C";
         CHAN_BOND_MODE            : in  string := "OFF";
         ALIGN_PARALLEL_CHECK      : in  bit := '1';
         USE_AUTORECOVER           : in  bit := '1';
         FIFO_ALMOST_EMPTY_OFFSET  : in  bit_vector := X"005";
         FIFO_ALMOST_FULL_OFFSET   : in  bit_vector := X"1F2" --498
    );
    port (

          GT_RXDATA           : in std_logic_vector(15 downto 0);
          GT_RXCHARISK        : in std_logic_vector(1  downto 0);
          GT_RXCHARISCOMMA    : in std_logic_vector(1  downto 0);
          GT_RXRUNDISP        : in std_logic_vector(1  downto 0);
          GT_RXNOTINTABLE     : in std_logic_vector(1  downto 0);
          GT_RXDISPERR        : in std_logic_vector(1  downto 0);
          GT_RXBUFSTATUS      : in std_logic_vector(2  downto 0);
          GT_RXCLKCORCNT      : in std_logic_vector(2  downto 0);
          GT_RXCHANBONDSEQ    : in std_logic;
          GT_RXCHANISALIGNED  : in std_logic;
          GT_RXCHANREALIGN    : in std_logic;
          GT_RXLOSSOFSYNC     : in std_logic_vector(1  downto 0);
          GT_RXVALID          : in std_logic;
          GT_RXUSRCLK2        : in std_logic;
          USER_RXUSRCLK2      : in std_logic;
          RESET               : in std_logic;
          CCI                 : in std_logic_vector(6 downto 0);

          USER_RXDATA          : out std_logic_vector(15 downto 0);
          USER_RXCHARISK       : out std_logic_vector(1 downto 0);
          USER_RXCHARISCOMMA   : out std_logic_vector(1 downto 0);
          USER_RXRUNDISP       : out std_logic_vector(1 downto 0);
          USER_RXNOTINTABLE    : out std_logic_vector(1 downto 0);
          USER_RXDISPERR       : out std_logic_vector(1 downto 0);
          USER_RXBUFSTATUS     : out std_logic_vector(2 downto 0);
          USER_RXCLKCORCNT     : out std_logic_vector(2 downto 0);
          USER_RXCHANBONDSEQ   : out std_logic;
          USER_RXCHANISALIGNED : out std_logic;
          USER_RXCHANREALIGN   : out std_logic;
          USER_RXLOSSOFSYNC    : out std_logic_vector(1 downto 0);
          USER_RXVALID         : out std_logic;
          CCO                  : out std_logic_vector(6 downto 0)
      );

end entity;

ARCHITECTURE top OF CC_2B_1SKP IS
    -- Write side datapath and CC match location
    signal lower_gt_data_c     : std_logic_vector(13 downto 0);
    signal upper_gt_data_c     : std_logic_vector(13 downto 0);
    signal write_mux_0_i       : std_logic_vector(1 downto 0);
    signal write_mux_1_i       : std_logic_vector(1 downto 0);
    signal write_data_fifo_i   : std_logic_vector(35 downto 0);
    signal write_cc_location_i : std_logic_vector(1 downto 0);
    signal deleted_cc_i        : std_logic;

    -- Write side FIFO
    signal almost_full_i            : std_logic;
    signal wfsm_mailbox_overflow_i  : std_logic;
    signal wr_en_i                  : std_logic;
    signal wr_err_i                 : std_logic;
    signal wfsm_idle_i              : std_logic;

    -- Read side datapath and CC match location
    signal  lower_user_data_i       : std_logic_vector (13 downto 0) ;
    signal  upper_user_data_i       : std_logic_vector (13 downto 0) ;
    signal  read_mux_0_i            : std_logic_vector (1 downto 0) ;
    signal  read_mux_1_i            : std_logic_vector (1 downto 0) ;
    signal  read_data_fifo_i        : std_logic_vector  (35 downto 0) ;
    signal  read_cc_location_i      : std_logic_vector (1 downto 0) ;
    signal  inserted_cc_i           : std_logic;
    signal  user_rxchanisaligned_i  : std_logic;
    signal  user_rxchanrealign_i    : std_logic;
    signal  user_rxlossofsync_i     : std_logic_vector(1 downto 0) ;
    signal  user_rxvalid_i          : std_logic;

    -- Read side FIFO
    signal  almost_empty_i          : std_logic;
    signal  rfsm_mailbox_overflow_i : std_logic;
    signal  empty_i                 : std_logic;
    signal  full_i                  : std_logic;
    signal  rd_en_i                 : std_logic;
    signal  rd_err_i                : std_logic;
    signal  rfsm_idle_i             : std_logic;

    -- Status
    signal user_rxbufstatus_c       : std_logic_vector(2 downto 0) ;
    signal user_rxclkcorcnt_c       : std_logic_vector(2 downto 0) ;

    -- synthesis attribute shreg_extract of reset_rxrecclk_r is no
    -- synthesis attribute shreg_extract of reset_rxusrclk2_r is no
    signal reset_rxrecclk_r           : std_logic_vector(3 downto 0) := "1111"; --/* synthesis syn_srlstyle = "registers" */ ;
    signal reset_rxusrclk2_r          : std_logic_vector(3 downto 0) := "1111"; --/* synthesis syn_srlstyle = "registers" */ ;

    -- Write side datapath and CC match location
    signal inserted_cc_r              : std_logic;
    signal gt_rxchanisaligned_r       : std_logic;
    signal gt_rxchanrealign_r         : std_logic;
    signal gt_rxlossofsync_r          : std_logic_vector(1 downto 0) ;
    signal gt_rxvalid_r               : std_logic;

    -- Write side FIFO
    signal wr_err_rxrecclk_domain_r   : std_logic;
    signal wr_err_r                   : std_logic;
    signal wr_err_r2                  : std_logic;

    -- Read side datapath and CC match location
    signal deleted_cc_r               : std_logic;
    signal user_rxchanisaligned_r     : std_logic;
    signal user_rxchanrealign_r       : std_logic;
    signal user_rxlossofsync_r        : std_logic_vector(1 downto 0);
    signal user_rxvalid_r             : std_logic;

    -- Status
    signal  user_rxbufstatus_r        : std_logic_vector(2 downto 0);
    signal  user_rxclkcorcnt_r        : std_logic_vector(2 downto 0);

    --FIFO Flags registers
    signal almost_empty_r             : std_logic;
    signal almost_empty_r2            : std_logic;
    signal almost_empty_r3            : std_logic;
    signal almost_full_r              : std_logic;
    signal almost_full_r2             : std_logic;
    signal almost_full_r3             : std_logic;

    -- Align status registers
    signal  upper_user_data_status_r  : std_logic;
    signal  lower_user_data_status_r  : std_logic;
    signal  user_align_status_r       : std_logic;

    -- assign
    signal align_status_i             : std_logic;
    signal gt_data_c                  : std_logic_vector(27 downto 0);
    signal UpperLower                 : std_logic_vector(27 downto 0);

  attribute ASYNC_REG                     : string;
  attribute ASYNC_REG of reset_rxusrclk2_r  : signal is "TRUE";
    

COMPONENT CC_2B_1SKP_DATA_PATH
PORT (
    CLK       : in std_logic;
    DATA_IN   : in std_logic_vector(27 downto 0);
    SEL_0     : in std_logic_vector(1  downto 0);
    SEL_1     : in std_logic_vector(1  downto 0);
    RST       : in std_logic;
    DATA_OUT  : out std_logic_vector(27 downto 0)
);
end component;

component CC_2B_1SKP_PATTERN_MATCH is
generic (
    --  Define the byte to detect
    CC_CHAR : in std_logic_vector(7 downto 0) := x"1C"
);
port (
   DATA_IN   : in std_logic_vector(27 downto 0);
   DATA_OUT  : out std_logic_vector(1 downto 0)
);
end component;
component CC_2B_1SKP_WFSM is
    generic (
     USE_AUTORECOVER  : in  bit := '1'
    );
    port (
        USER_CLK           : in std_logic;
        RESET              : in std_logic;
        AF_STATUS          : in std_logic;
        BYTE_STATUS        : in std_logic_vector(1 downto 0);
        SEL_0              : out std_logic_vector(1 downto 0);
        SEL_1              : out std_logic_vector(1 downto 0);
        WEN                : out std_logic;
        WFSM_IDLE          : out std_logic;
        DELETED_CC         : out std_logic;
        MAILBOX_OVERFLOW   : out std_logic
    );
end component;

component CC_2B_1SKP_RFSM is
    generic (
     USE_AUTORECOVER  : in  bit := '1'
    );
    port (
        USER_CLK           : in std_logic;
        RESET              : in std_logic;
        AE_STATUS          : in std_logic;
        AE_INIT            : in std_logic;
        BYTE_STATUS        : in std_logic_vector(1 downto 0);
        SEL_0              : out std_logic_vector(1 downto 0);
        SEL_1              : out std_logic_vector(1 downto 0);
        REN                : out std_logic;
        RFSM_IDLE          : out std_logic;
        INSERTED_CC        : out std_logic;
        MAILBOX_OVERFLOW   : out std_logic
    );
end component;

--********************** Main Body of Code ***********************************

    --__________ Defining Master & Slave for resets __________________________
begin
    generateReset : if (CHAN_BOND_MODE = "OFF" or CHAN_BOND_MODE = "MASTER") generate
    begin
        msResets : process (reset_rxrecclk_r(0), reset_rxusrclk2_r(0))
        begin
             CCO(1) <= reset_rxusrclk2_r(0);
             CCO(3) <= reset_rxrecclk_r(0);
        end process msResets;

            -- Synchronize reset to GT_RXUSRCLK2
            -- Making it 3 clock cycles long to keep it in sync with
            -- the reset based on USER_RXUSRCLK2
        syncGTResets : process (GT_RXUSRCLK2,reset_rxusrclk2_r(0))
        begin
            if  (reset_rxusrclk2_r(0) = '1') then
                reset_rxrecclk_r <= "1111" after 1 ns;
            elsif (rising_edge (GT_RXUSRCLK2))  then
                    reset_rxrecclk_r <= ('0' & reset_rxrecclk_r(3 downto 1)) after 1 ns;
            end if;
        end process syncGTResets;

            -- Synchronize reset to USER_RXUSRCLK2
            -- The reset register for the USER_RXUSRCLK2 is 3 bits wide because
            -- the RESET of the FIFO36 needs to be asserted for three clock
            -- cycles long
        syncUserResets : process (USER_RXUSRCLK2,RESET)
        begin
            if (RESET = '1') then
                reset_rxusrclk2_r <= "1111" after 1 ns;
            elsif (rising_edge (USER_RXUSRCLK2 )) then
                reset_rxusrclk2_r <= ( '0' & reset_rxusrclk2_r(3 downto 1))after 1 ns;
            end if;
        end process syncUserResets;
    end generate generateReset;
    genResetSlave : if (CHAN_BOND_MODE = "SLAVE") generate
    begin
        cciProc : process (CCI(3), CCI(1))
        begin
            reset_rxrecclk_r(0) <= CCI(3);
            reset_rxusrclk2_r(0) <= CCI(1);
        end process cciProc;
    end generate genResetSlave;

    --__________ Defining Master & Slave for USE_AUTORECOVER _________________

    generate_flag_pulses : if (USE_AUTORECOVER = '1' and CHAN_BOND_MODE = "MASTER") generate
    begin
        CCO(0) <= almost_empty_r2;
        CCO(2) <= almost_full_r2;
        CCO(6) <= almost_empty_r;

        -- Write side
        writeSide : process (GT_RXUSRCLK2)
        begin
            if (GT_RXUSRCLK2 = '1' and GT_RXUSRCLK2'EVENT) then
                if(reset_rxrecclk_r(0) = '1') then
                    almost_full_r <=  '0' after 1 ns;
                    almost_full_r2 <= '0' after 1 ns;
                    almost_full_r3 <= '0' after 1 ns;
                else
                    almost_full_r <= almost_full_i after 1 ns;
                    if ((almost_full_r2 xor almost_full_r3) = '1') then
                        almost_full_r2 <=  '0' after 1 ns;
                    else
                        almost_full_r2 <=  (almost_full_i and wfsm_idle_i) after 1 ns;
                    end if;
                    almost_full_r3 <= almost_full_r2 after 1 ns;
                end if;
            end if;
        end process writeSide;

        -- Read side
        readSide : process (USER_RXUSRCLK2)
        begin
            if (USER_RXUSRCLK2 = '1' and USER_RXUSRCLK2'EVENT) then
                if(reset_rxusrclk2_r(0)= '1') then
                    almost_empty_r <=  '1' after 1 ns;
                    almost_empty_r2 <= '0' after 1 ns;
                    almost_empty_r3 <= '0' after 1 ns;
                else
                    almost_empty_r <= almost_empty_i after 1 ns;
                    if  ((almost_empty_r2 xor almost_empty_r3) = '1') then
                        almost_empty_r2 <= '0'after 1 ns;
                    else
                        almost_empty_r2 <= (almost_empty_i and rfsm_idle_i) after 1 ns;
                    end if;
                    almost_empty_r3 <= almost_empty_r2 after 1 ns;
                end if;
            end if;
        end process readSide;
    end generate generate_flag_pulses;

    generate_master_flag_levels : if ((USE_AUTORECOVER = '0' and  CHAN_BOND_MODE = "MASTER") or CHAN_BOND_MODE = "OFF" ) generate
    begin
        CCO(0) <= almost_empty_r2;
        CCO(2) <= almost_full_r2;

        almostProcess : process (almost_full_r,almost_empty_r)
        begin
            almost_full_r2<=almost_full_r;
            almost_empty_r2<=almost_empty_r;
        end process almostProcess;

        -- Write side
        masterWrite : process (GT_RXUSRCLK2)
        begin
            if (GT_RXUSRCLK2 = '1' and GT_RXUSRCLK2'EVENT) then
                if(reset_rxrecclk_r(0) = '1') then
                    almost_full_r <= '0' after 1 ns;
                else
                    almost_full_r <= almost_full_i after 1 ns;
                end if;
            end if;
        end process masterWrite;

        -- Read side
        masterRead : process (USER_RXUSRCLK2)
        begin
            if (USER_RXUSRCLK2 = '1' and USER_RXUSRCLK2'EVENT) then
                if(reset_rxusrclk2_r(0) = '1') then
                    almost_empty_r <= '1' after 1 ns;
                else
                    almost_empty_r <= almost_empty_i after 1 ns;
                end if;
            end if;
         end process masterRead;
     end generate generate_master_flag_levels;


    generate_slave_flag_pulses : if (USE_AUTORECOVER = '1' and CHAN_BOND_MODE = "SLAVE") generate
    begin
        slaveFlagPulse : process (CCI(2),CCI(0),CCI(6))
        begin
            almost_full_r2 <= CCI(2);
            almost_empty_r2 <= CCI(0);
            almost_empty_r <= CCI(6);
        end process slaveFlagPulse;
    end generate generate_slave_flag_pulses;


    generate_slave_flag_levels : if (USE_AUTORECOVER = '0' and CHAN_BOND_MODE = "SLAVE") generate
    begin
        slaveFlagLevels : process (CCI(2),CCI(0),almost_empty_r)
        begin
            almost_full_r2 <= CCI(2);
            almost_empty_r <= CCI(0);
            almost_empty_r2 <= almost_empty_r;
        end process slaveFlagLevels;
    end generate generate_slave_flag_levels;

    --__________ Defining the align status flag__________________--
    generate_m_align : if (ALIGN_PARALLEL_CHECK = '1' and CHAN_BOND_MODE = "MASTER") generate
    begin
        CCO(5) <= upper_user_data_status_r;
        CCO(4) <= lower_user_data_status_r;
        USER_RXCHANISALIGNED <= user_rxchanisaligned_r;

        --Upper and Lower Data byte
        upperLower : process (USER_RXUSRCLK2)
        begin
            if (USER_RXUSRCLK2 = '1' and USER_RXUSRCLK2'EVENT) then
                if (reset_rxusrclk2_r(0) = '1') then
                    upper_user_data_status_r <= '0' after 1 ns;
                    lower_user_data_status_r <= '0' after 1 ns;
                else
                    if (upper_user_data_i(8 downto 0) = ('1' & ALIGN_CHAR)) then
                        upper_user_data_status_r <=  '1' after 1 ns;
                    else
                        upper_user_data_status_r <= '0' after 1 ns;
                    end if;
                    if (lower_user_data_i(8 downto 0) = ('1' & ALIGN_CHAR)) then
                        lower_user_data_status_r <=  '1' after 1 ns;
                    else
                        lower_user_data_status_r <= '0' after 1 ns;
                    end if;
                end if;
            end if;
         end process upperLower;
    end generate generate_m_align;

    generate_s_align : if (ALIGN_PARALLEL_CHECK = '1' and CHAN_BOND_MODE = "SLAVE") generate
    begin
        align_stat : process (CCI(5), CCI(4), user_align_status_r, lower_user_data_status_r, upper_user_data_status_r, user_rxchanisaligned_r )
        begin
        USER_RXCHANISALIGNED <= user_align_status_r;
        align_status_i <= ( (CCI(5) xnor  upper_user_data_status_r ) and (CCI(4) xnor lower_user_data_status_r) and user_rxchanisaligned_r);
        end process align_stat;
        --Upper and Lower Data byte
        upperLowerS : process (USER_RXUSRCLK2)
        begin
            if (USER_RXUSRCLK2 = '1' and USER_RXUSRCLK2'EVENT) then
                if (reset_rxusrclk2_r(0) = '1' ) then
                    upper_user_data_status_r <= '0' after 1 ns;
                    lower_user_data_status_r <= '0' after 1 ns;
                else
                    if (upper_user_data_i(8 downto 0) = ('1'& ALIGN_CHAR)) then
                        upper_user_data_status_r <=  '1'after 1 ns;
                    else
                        upper_user_data_status_r <= '0' after 1 ns;
                    end if;
                    if (lower_user_data_i(8 downto 0) = ('1'& ALIGN_CHAR)) then
                        lower_user_data_status_r <=  '1' after 1 ns;
                    else
                        lower_user_data_status_r <= '0' after 1 ns;
                    end if;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then
                      user_align_status_r <= '0' after 1 ns;
                else
                    if (CCI(4)= '1' or CCI(5) = '1' or  upper_user_data_status_r = '1' or lower_user_data_status_r = '1' or user_rxchanisaligned_r = '0') then
                        user_align_status_r <= align_status_i;
                    else
                        user_align_status_r <= user_align_status_r;
                    end if;
                end if;
            end if;
        end process upperLowerS;
       end generate generate_s_align;



         generate_off_align : if ( not(ALIGN_PARALLEL_CHECK = '1' and CHAN_BOND_MODE = "SLAVE" )and not (ALIGN_PARALLEL_CHECK = '1' and CHAN_BOND_MODE = "MASTER")) generate
         begin
             USER_RXCHANISALIGNED <= user_rxchanisaligned_r;
         end generate generate_off_align;

    --_________________ Logic for writing to the elastic buffer ______________

    -- Combine incoming GT data and control signals into the lower and upper
    -- portions of the word.  There are 16 bits of data and control in the
    -- upper and lower locations of the word.
    --
    -- The modules below do the following when the GT_RXUSRCLK2 is faster than
    -- the USER_RXUSRCLK2:
    -- - Find the CC sequence in the data path and mark it whenever the
    --   FIFO becomes full
    -- - Generate control signals to the FIFO
    -- - Select the appropriate lower or upper portions of the word in the
    --   datapath whenever a CC sequence is deleted
    lower_gt_data_c  <=    GT_RXCHANBONDSEQ &     -- (13)
                           GT_RXDISPERR(0)&      -- (12)
                           GT_RXNOTINTABLE(0)&   -- (11)
                           GT_RXRUNDISP(0)&      -- (10)
                           GT_RXCHARISCOMMA(0)&  -- (9)
                           GT_RXCHARISK(0)&      -- (8)
                           GT_RXDATA(7 downto 0)        -- (7downto0)
                           ;

    upper_gt_data_c  <= (  GT_RXCHANBONDSEQ &     -- (13)
                                  GT_RXDISPERR(1)&      -- (12)
                                  GT_RXNOTINTABLE(1)&   -- (11)
                                  GT_RXRUNDISP(1)&      -- (10)
                                  GT_RXCHARISCOMMA(1)&  -- (9)
                                  GT_RXCHARISK(1)&      -- (8)
                                  GT_RXDATA(15 downto 8)       -- (7 downto 0)
                              );



    -- Instantiate the datapath for the write side
    gt_data_c <=  (upper_gt_data_c & lower_gt_data_c); -- make a globally static input for Data_in

    write_data_path_i : CC_2B_1SKP_DATA_PATH
    port map(
        CLK => GT_RXUSRCLK2,
        DATA_IN => gt_data_c,
        SEL_0 => write_mux_0_i,
        SEL_1 => write_mux_1_i,
        RST => reset_rxrecclk_r(0),
        DATA_OUT => write_data_fifo_i(27 downto 0)
    );

    -- Synchronize the RXCHANISALIGNED signal and pipe it through the FIFO


    syncChanAligns : process (GT_RXUSRCLK2)
    begin
        if (GT_RXUSRCLK2 = '1' and GT_RXUSRCLK2'EVENT) then
            if (reset_rxrecclk_r(0) = '1') then
                gt_rxchanisaligned_r <= '0' after 1 ns;
            else
                gt_rxchanisaligned_r <= GT_RXCHANISALIGNED after 1 ns;
            end if;
            if (reset_rxrecclk_r(0) = '1') then
                gt_rxchanrealign_r <= '0' after 1 ns;
            else
                gt_rxchanrealign_r <= GT_RXCHANREALIGN after 1 ns;
            end if;
            if (reset_rxrecclk_r(0) = '1') then
                gt_rxlossofsync_r(1 downto 0) <= "00" after 1 ns;
            else
                gt_rxlossofsync_r(1 downto 0) <= GT_RXLOSSOFSYNC(1 downto 0) after 1 ns;
            end if;
            if (reset_rxrecclk_r(0) = '1') then
                gt_rxvalid_r <= '0' after 1 ns;
            else
                gt_rxvalid_r <= GT_RXVALID after 1 ns;
            end if;
        end if;
     end process syncChanAligns;

         write_data_fifo_i(28) <= gt_rxchanisaligned_r;
         write_data_fifo_i(29) <= gt_rxchanrealign_r;
         write_data_fifo_i(31 downto 30) <= gt_rxlossofsync_r(1 downto 0);
         write_data_fifo_i(32) <= GT_RXBUFSTATUS(2);
         write_data_fifo_i(33) <= deleted_cc_i;
         write_data_fifo_i(34) <= gt_rxvalid_r;
         write_data_fifo_i(35) <= '0'; -- Tied the remaining bits of the FIFO to ground


    -- Instantiate the pattern match for the write side for detecting
    -- a CC sequence
   write_pattern_match_i : CC_2B_1SKP_PATTERN_MATCH
   generic map (
        CC_CHAR => CC_CHAR)
   port map(
        DATA_IN => gt_data_c,
        DATA_OUT => write_cc_location_i
    );

    write_fsm_i : CC_2B_1SKP_WFSM
    generic map(
        USE_AUTORECOVER => USE_AUTORECOVER
    )
    port map(
        USER_CLK => GT_RXUSRCLK2,
        RESET => reset_rxrecclk_r(0),
        BYTE_STATUS => write_cc_location_i,
        AF_STATUS => almost_full_r2,
        SEL_0 => write_mux_0_i,
        SEL_1 => write_mux_1_i,
        WEN => wr_en_i,
        WFSM_IDLE => wfsm_idle_i,
        DELETED_CC => deleted_cc_i,
        MAILBOX_OVERFLOW => wfsm_mailbox_overflow_i
    );


    --___________________________ Logic for Buffer Read interface ____________

    -- Split the lower and upper portions of the word into individual signals
    --
    -- The modules below do the following when the GT_RXUSRCLK2 is slower than
    -- the USER_RXUSRCLK2:
    -- - Find the CC sequence in the data path and mark it whenever the
    --   FIFO becomes empty
    -- - Generate control signals to the FIFO
    -- - Select the appropriate lower or upper portions of the word in the
    --   datapath whenever a CC sequence is added
     USER_RXCHANBONDSEQ <= upper_user_data_i(13) or lower_user_data_i(13);
     USER_RXDISPERR <= (upper_user_data_i(12) & lower_user_data_i(12));
     USER_RXNOTINTABLE <= (upper_user_data_i(11) & lower_user_data_i(11));
     USER_RXRUNDISP <= (upper_user_data_i(10) & lower_user_data_i(10));
     USER_RXCHARISCOMMA <= (upper_user_data_i(9) & lower_user_data_i(9));
     USER_RXCHARISK <= (upper_user_data_i(8) & lower_user_data_i(8));
     USER_RXDATA <= (upper_user_data_i(7 downto 0) & lower_user_data_i(7 downto 0));

    -- Delay the RXCHANISALIGNED piped from the FIFO going into the SRL16 by
    -- 4 clock cycles.  A FF is added after the SRL16 before going to the user
    -- which will delay the signal by 6 clock cycles (this includes the FF
    -- before the FIFO).
    srl16_user_rxchanisaligned_i : SRL16
    port map (
        Q     => user_rxchanisaligned_i,
        A0    => '1',
        A1    => '1',
        A2    => '0',
        A3    => '0',
        CLK   => USER_RXUSRCLK2,
        D     => read_data_fifo_i(28)
    );


    -- Delay the RXCHANREALIGN piped from the FIFO going into the SRL16 by
    -- 4 clock cycles.  A FF is added after the SRL16 before going to the user
    -- which will delay the signal by 6 clock cycles (this includes the FF
    -- before the FIFO).
    srl16_user_rxchanrealign_i : SRL16
    port map (
        Q     => user_rxchanrealign_i,
        A0    => '1',
        A1    => '1',
        A2    => '0',
        A3    => '0',
        CLK   => USER_RXUSRCLK2,
        D     => read_data_fifo_i(29)
    );


    -- Delay the RXLOSSOFSYNC(1 to 0) piped from the FIFO going into the SRL16 by
    -- 4 clock cycles.  A FF is added after the SRL16 before going to the user
    -- which will delay the signal by 6 clock cycles (this includes the FF
    -- before the FIFO).
    srl16_user_rxlossofsync0_i : SRL16
    port map(
        Q     => user_rxlossofsync_i(0),
        A0    => '1',
        A1    => '1',
        A2    => '0',
        A3    => '0',
        CLK   => USER_RXUSRCLK2,
        D     => read_data_fifo_i(30)
    );

    srl16_user_rxlossofsync1_i : SRL16
    port map(
        Q     => user_rxlossofsync_i(1),
        A0    => '1',
        A1    => '1',
        A2    => '0',
        A3    => '0',
        CLK   => USER_RXUSRCLK2,
        D     => read_data_fifo_i(31)
    );

    -- Delay the RXVALID piped from the FIFO going into the SRL16 by
    -- 4 clock cycles.  A FF is added after the SRL16 before going to the user
    -- which will delay the signal by 6 clock cycles (this includes the FF
    -- before the FIFO).
    srl16_user_rxvalid_i : SRL16
    port map (
        Q     => user_rxvalid_i,
        A0    => '1',
        A1    => '1',
        A2    => '0',
        A3    => '0',
        CLK   => USER_RXUSRCLK2,
        D     => read_data_fifo_i(34)
    );

    -- Instantiate the datapath for the read side

--    UpperLower <= (upper_user_data_i & lower_user_data_i); --make a static expression for DATA_OUT port
    read_data_path_i : CC_2B_1SKP_DATA_PATH
    port map(
        CLK => USER_RXUSRCLK2,
        DATA_IN => read_data_fifo_i(27 downto 0),
        SEL_0 => read_mux_0_i,
        SEL_1 => read_mux_1_i,
        RST => reset_rxusrclk2_r(0),
        DATA_OUT => UpperLower
    );
    upper_user_data_i <= UpperLower(27 downto 14);
    lower_user_data_i <= UpperLower(13 downto 0);
    -- Instantiate the pattern match for the read side for detecting
    -- a CC sequence
    read_pattern_match_i : CC_2B_1SKP_PATTERN_MATCH
    generic map (
        CC_CHAR  => CC_CHAR
    )
    port map (
        DATA_IN => read_data_fifo_i(27 downto 0),
        DATA_OUT => read_cc_location_i
    );

    -- Instantiate the FSM for the read side
    read_fsm_i : CC_2B_1SKP_RFSM
    generic map(
        USE_AUTORECOVER  => USE_AUTORECOVER
    )
    port map(
        USER_CLK => USER_RXUSRCLK2,
        RESET => reset_rxusrclk2_r(0),
        BYTE_STATUS => read_cc_location_i,
        AE_STATUS => almost_empty_r2,
        AE_INIT => almost_empty_r,
        SEL_0 => read_mux_0_i,
        SEL_1 => read_mux_1_i,
        REN => rd_en_i,
        RFSM_IDLE => rfsm_idle_i,
        INSERTED_CC => inserted_cc_i,
        MAILBOX_OVERFLOW => rfsm_mailbox_overflow_i
    );


    --__________________________ FIFO Instantiation __________________________

    -- Fifo used to transfer data and control between read/write clock domains
    -- Clock correction characters are inserted/deleted to insure FIFO is
    -- never full or empty.

    cc_fifo : FIFO18_36
      generic map(
          ALMOST_FULL_OFFSET    => FIFO_ALMOST_FULL_OFFSET,
          ALMOST_EMPTY_OFFSET   => FIFO_ALMOST_EMPTY_OFFSET,
        DO_REG                => 1,         -- Enable output register (0 or 1)
                                            -- Must be 1 if EN_SYN = "FALSE"
--          EN_SYN                => TRUE,  -- "FALSE" - asynchronous
          EN_SYN                => FALSE,  -- "FALSE" - asynchronous
                                            -- "TRUE"  - synchronous
          FIRST_WORD_FALL_THROUGH  => FALSE
        )
    port map(
        ALMOSTEMPTY   => almost_empty_i,
        ALMOSTFULL    => almost_full_i,
        DO            => read_data_fifo_i(31 downto 0),
        DOP           => read_data_fifo_i(35 downto 32),
        EMPTY         => empty_i,
        FULL          => full_i,
        RDCOUNT       => open,
        RDERR         => rd_err_i,
        WRCOUNT       => open,
        WRERR         => wr_err_i,
        DI            => write_data_fifo_i(31 downto 0),
        DIP           => write_data_fifo_i(35 downto 32),
        RDCLK         => USER_RXUSRCLK2,
        RDEN          => rd_en_i,
        RST           => reset_rxusrclk2_r(0),
        WRCLK         => GT_RXUSRCLK2,
        WREN          => wr_en_i
    );

    --__________________________ Status Indicators ___________________________

    gtStatusIndicators : process (GT_RXUSRCLK2)
    begin
        if (GT_RXUSRCLK2 = '1' and GT_RXUSRCLK2'EVENT) then
            if (reset_rxrecclk_r(0) = '1' ) then
                wr_err_rxrecclk_domain_r <= '0' after 1 ns;
            else
                wr_err_rxrecclk_domain_r <= wr_err_i or wfsm_mailbox_overflow_i after 1 ns;
            end if;
        end if;
    end process gtStatusIndicators;
    -- Error signal indicator
    -- WRERR from the FIFO is synchronous to GT_RXUSRCLK2 - need to double flop
    --  it to the USER_RXUSRCLK2 domain.

    errorSignalIndicators : process (USER_RXUSRCLK2)
        begin
            if (USER_RXUSRCLK2 = '1' and USER_RXUSRCLK2'EVENT) then
                if (reset_rxusrclk2_r(0) = '1') then
                    user_rxchanisaligned_r <= '0' after 1 ns;
                else
                    user_rxchanisaligned_r <= user_rxchanisaligned_i after 1 ns;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then
                    user_rxchanrealign_r <= '0' after 1 ns;
                else
                    user_rxchanrealign_r <= user_rxchanrealign_i after 1 ns;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then
                    user_rxlossofsync_r(1 downto 0) <= "00" after 1 ns;
                else
                    user_rxlossofsync_r(1 downto 0) <= user_rxlossofsync_i(1 downto 0) after 1 ns;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then
                    user_rxvalid_r <= '0' after 1 ns;
                else
                    user_rxvalid_r <= user_rxvalid_i after 1 ns;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then
                    wr_err_r  <= '0' after 1 ns;
                    wr_err_r2 <= '0' after 1 ns;
                else
                    wr_err_r  <= wr_err_rxrecclk_domain_r after 1 ns;
                    wr_err_r2 <= wr_err_r after 1 ns;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then -- Register the USER_RXBUFSTATUS(2 downto 0) before presenting it to the user
                    user_rxbufstatus_r(2 downto 0) <= "000" after 1 ns;
                else
                    user_rxbufstatus_r(2 downto 0) <= user_rxbufstatus_c(2 downto 0) after 1 ns;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then   -- Register the inserted_cc_i signal
                    inserted_cc_r <= '0' after 1 ns;
                else
                    inserted_cc_r <= inserted_cc_i after 1 ns;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then -- Register the deleted_cc_i signal that is piped through the FIFO as bit 33 of the data
                    deleted_cc_r <= '0' after 1 ns;
                else
                    deleted_cc_r <= read_data_fifo_i(33) after 1 ns;
                end if;
                if (reset_rxusrclk2_r(0) = '1') then -- Register the USER_RXCLKCORCNT(2 downto 0) before presenting it to the user
                    user_rxclkcorcnt_r(2 downto 0) <= "000" after 1 ns;
                else
                    user_rxclkcorcnt_r(2 downto 0) <= user_rxclkcorcnt_c(2 downto 0) after 1 ns;
                end if;
            end if;
        end process errorSignalIndicators;

    -- Decode all the signals for the USER_RXCLKCORCNT(2 downto 0)
    -- USER_RXCLKCORCNT(2 downto 0) = 000 - No clock correction
    -- USER_RXCLKCORCNT(2 downto 0) = 001 - 1 CC_CHAR skipped
    -- USER_RXCLKCORCNT(2 downto 0) = 111 - 1 CC_CHAR added

    -- USER_RXBUFSTATUS(2 downto 0) = 101 - Rx elastic underflow
    --    Condition when GT_RXBUFSTATUS(2) or RDERR FIFO is High
    -- USER_RXBUFSTATUS(2 downto 0) = 110 - Rx elastic overflow
    --    Condition when GT_RXBUFSTATUS(2) or WRERR FIFO is High
    -- GT_RXBUFSTATUS(2) from the GTX is piped through the FIFO as bit 32 of
    --    the data
    USER_RXCHANREALIGN <= user_rxchanrealign_r;
    USER_RXLOSSOFSYNC(1 downto 0) <= user_rxlossofsync_r(1 downto 0);
    USER_RXVALID <= user_rxvalid_r;
    user_rxbufstatus_c(2) <= wr_err_r2 or rd_err_i or rfsm_mailbox_overflow_i or read_data_fifo_i(32);
    user_rxbufstatus_c(1) <= wr_err_r2;
    user_rxbufstatus_c(0) <= rd_err_i or rfsm_mailbox_overflow_i;
    USER_RXBUFSTATUS(2 downto 0) <= user_rxbufstatus_r(2 downto 0);
    USER_RXCLKCORCNT(2 downto 0) <= user_rxclkcorcnt_r(2 downto 0);
    clkcnt: process (inserted_cc_r,deleted_cc_r)
    begin
        if (deleted_cc_r = '1') then
            user_rxclkcorcnt_c <= "001" ;
        else
            if (inserted_cc_r = '1') then
                user_rxclkcorcnt_c <= "111";
            else
                user_rxclkcorcnt_c <= "000";
            end if;
        end if;
    end process clkcnt;
end architecture top;


library std;
--    use std.textio.all;
library IEEE;
    use IEEE.std_logic_1164.all;
    use IEEE.std_logic_textio.all;
    use IEEE.Std_logic_unsigned.all;
    use IEEE.numeric_std.all;
entity CC_2B_1SKP_PATTERN_MATCH is
generic (
    --  Define the byte to detect
    CC_CHAR : in std_logic_vector(7 downto 0) := x"1C"
);
port (
   DATA_IN   : in std_logic_vector(27 downto 0);
   DATA_OUT  : out std_logic_vector(1 downto 0)
);
end entity CC_2B_1SKP_PATTERN_MATCH;

ARCHITECTURE pattern_match OF CC_2B_1SKP_PATTERN_MATCH IS
    -- Wires declaration
    signal match_char : std_logic_vector(7 downto 0);
--    signal data_out : std_logic_vector(1 downto 0);

    -- Main body of the code
begin
    match_char <= CC_CHAR;
    matchem : process (DATA_IN, match_char)
    begin
        -- Lower portion of the word is the match_char - i.e. xx(CC_CHAR)
        -- DATA_IN(8) is RXCHARISK from the data path
        if (DATA_IN(8 downto 0) = ('1' & match_char)) then
            DATA_OUT <= "01";

        -- Upper portion of the word is the match_char - i.e. (CC_CHAR)xx
        -- DATA_IN(24) is RXCHARISK from the data path
        else
            if (DATA_IN(22 downto 14) = ('1'& match_char)) then
                DATA_OUT <= "10";
            -- Lower & upper portions of the word are the match_char
            -- i.e. (CC_CHAR)(CC_CHAR)
            else
                if ((DATA_IN(22 downto 14) & DATA_IN(8 downto 0)) = ('1' & match_char & '1' & match_char)) then
                    DATA_OUT <= "01";
                -- No match
                else
                    DATA_OUT <= "00";
                end if;
            end if;
        end if;
    end process matchem;
end architecture pattern_match;

------------------------------------------------------------------------------
--
--  CC_2B_1SKP_WFSM
--
--
--
--  Description: This module performs clock correction in the FPGA
--               fabric instead of depending on the Virtex-5 GTX built-in
--               clock correction capability.
--
--               * Supports a 2-byte data width / 1-byte CC character
--
------------------------------------------------------------------------------
library std;
--    use std.textio.all;
library IEEE;
    use IEEE.std_logic_1164.all;
    use IEEE.std_logic_textio.all;
    use IEEE.Std_logic_unsigned.all;
    use IEEE.numeric_std.all;
---entity declarations--------------
entity CC_2B_1SKP_WFSM is
    generic (
     USE_AUTORECOVER  : in  bit := '1'
    );
    port (
        USER_CLK           : in std_logic;
        RESET              : in std_logic;
        AF_STATUS          : in std_logic;
        BYTE_STATUS        : in std_logic_vector(1 downto 0);
        SEL_0              : out std_logic_vector(1 downto 0);
        SEL_1              : out std_logic_vector(1 downto 0);
        WEN                : out std_logic;
        WFSM_IDLE          : out std_logic;
        DELETED_CC         : out std_logic;
        MAILBOX_OVERFLOW   : out std_logic
    );
 end entity;

ARCHITECTURE write_fsm OF CC_2B_1SKP_WFSM IS

SIGNAL CurrentState           :std_logic_vector(9 downto 0) ; -- states;
  -- declare the enumeration type



  -- assign the states
--  ATTRIBUTE enum_encoding :  string;
--  ATTRIBUTE enum_encoding OF states: TYPE IS "0000000001 0000000010 0000000100 0000001000 0000010000 0000100000 0001000000 0010000000 0100000000 1000000000";
constant INIT_STATE               :std_logic_vector(9 downto 0)   := "0000000001";
constant WRITE_CNT0_STATE         :std_logic_vector(9 downto 0)   := "0000000010";
constant WRITE_CNT0_WAIT_STATE    :std_logic_vector(9 downto 0)   := "0000000100";
constant DEL_CNT0_0_STATE         :std_logic_vector(9 downto 0)   := "0000001000";
constant DEL_CNT0_1_STATE         :std_logic_vector(9 downto 0)   := "0000010000";
constant WRITE_CNT1_STATE         :std_logic_vector(9 downto 0)   := "0000100000";
constant DEL_CNT1_0_STATE         :std_logic_vector(9 downto 0)   := "0001000000";
constant DEL_CNT1_1_STATE         :std_logic_vector(9 downto 0)   := "0010000000";
constant DEL_CNT1_2_STATE         :std_logic_vector(9 downto 0)   := "0100000000";
constant WAIT_FIFO_CLEAR_STATE    :std_logic_vector(9 downto 0)   := "1000000000";

constant INIT               :integer   := 0;
constant WRITE_CNT0         :integer   := 1;
constant WRITE_CNT0_WAIT    :integer   := 2;
constant DEL_CNT0_0         :integer   := 3;
constant DEL_CNT0_1         :integer   := 4;
constant WRITE_CNT1         :integer   := 5;
constant DEL_CNT1_0         :integer   := 6;
constant DEL_CNT1_1         :integer   := 7;
constant DEL_CNT1_2         :integer   := 8;
constant WAIT_FIFO_CLEAR    :integer   := 9;

  -- the state vectors
  SIGNAL  status_WCNT0_r        : std_logic_vector(1 downto 0);
  SIGNAL  status_WCNT1_r        : std_logic_vector(1 downto 0);
  SIGNAL  wait_fifo_clear_cnt_r : std_logic_vector(1 downto 0);
  SIGNAL  mailbox_r             : std_logic_vector(1 downto 0);
  SIGNAL  mailbox_over          : std_logic;

 ATTRIBUTE fsm_encoding :string;
 ATTRIBUTE fsm_encoding of CurrentState: signal is "one-hot";

BEGIN

  -- the combinatorial process
  write_fsm_state : PROCESS (USER_CLK)
  BEGIN
    -- state transitions
    if ( USER_CLK = '1' and USER_CLK'event) then
        if(RESET ='1') then
            CurrentState       <= INIT_STATE after 1 ns;
            status_WCNT0_r     <= "00" after 1 ns;
            status_WCNT1_r     <= "00" after 1 ns;
        else
        CASE CurrentState IS
            when INIT_STATE =>
                CurrentState <= WRITE_CNT0_STATE after 1 ns;
            when WRITE_CNT0_STATE =>
                if (mailbox_r /= "00") then
                     CurrentState <= WRITE_CNT0_WAIT_STATE after 1 ns;
                else
                    CurrentState <= WRITE_CNT0_STATE after 1 ns;
                end if;
                status_WCNT1_r <= "00" after 1 ns; -- Reset the status flag
            when  WRITE_CNT0_WAIT_STATE =>
                if (BYTE_STATUS /= "00") then
                    CurrentState <= DEL_CNT0_0_STATE after 1 ns ;
                    status_WCNT0_r <= BYTE_STATUS after 1 ns;
                else
                    CurrentState <= WRITE_CNT0_WAIT_STATE after 1 ns;
                    status_WCNT0_r <= "00" after 1 ns ;
                end if;
            when DEL_CNT0_0_STATE =>
                 CurrentState <= DEL_CNT0_1_STATE after 1 ns;
                      --Special case
            when DEL_CNT0_1_STATE =>
                CurrentState <= WRITE_CNT1_STATE after 1 ns;
            when WRITE_CNT1_STATE =>
                if (BYTE_STATUS /= "00") then
                    CurrentState <= DEL_CNT1_0_STATE after 1 ns;
                    status_WCNT1_r <= BYTE_STATUS after 1 ns;
                else
                    CurrentState <= WRITE_CNT1_STATE;
                    status_WCNT1_r <=  "00" after 1 ns;
                end if;
                status_WCNT0_r <=  "00" after 1 ns;
            --Special case
            when DEL_CNT1_0_STATE =>
                CurrentState <= DEL_CNT1_1_STATE after 1 ns;
            when DEL_CNT1_1_STATE =>
                CurrentState <=DEL_CNT1_2_STATE after 1 ns;
            when DEL_CNT1_2_STATE =>
                CurrentState <= WAIT_FIFO_CLEAR_STATE after 1 ns;
            -- State to give the FIFO enough time to de-assert the Almost
            -- Full Flag after the de-assertion of the WREN signal
            when WAIT_FIFO_CLEAR_STATE =>
                if (wait_fifo_clear_cnt_r = "00") then
                    CurrentState <= WRITE_CNT0_STATE after 1 ns;
                else
                    CurrentState <= WAIT_FIFO_CLEAR_STATE after 1 ns;
                end if;
             when others =>
                    CurrentState <= INIT_STATE;
            end case;
        end if;
    end if;
end process write_fsm_state;

write_fsm_combinatorial : process (CurrentState, status_WCNT0_r, status_WCNT1_r)
begin
    case CurrentState is
        when INIT_STATE =>
            SEL_0 <= "00";
            SEL_1 <= "00";
            WEN <= '0';
        when WRITE_CNT0_STATE | WRITE_CNT0_WAIT_STATE | WAIT_FIFO_CLEAR_STATE =>
            SEL_0 <= "00";
            SEL_1 <= "00";
            WEN   <= '1';
        when DEL_CNT0_0_STATE =>
            SEL_0 <= "00";
            SEL_1 <= "00";
            WEN   <= '1';
        -- Special case
        when DEL_CNT0_1_STATE =>
            WEN <= '1';
            case status_WCNT0_r is
                when "01" =>
                    SEL_0 <= "11";
                    SEL_1 <= "10";
                when "10" =>
                    SEL_0 <= "00";
                    SEL_1 <= "10";
                when others =>
                    SEL_0 <= "00";
                    SEL_1 <= "00";
            end case;
        when WRITE_CNT1_STATE =>
            SEL_0 <= "11";
            SEL_1 <= "10";
            WEN <=   '1';
        -- Special case
        when DEL_CNT1_0_STATE =>
            WEN <= '1';
            case status_WCNT1_r is
                when "01"  =>
                    SEL_0 <= "11";
                    SEL_1 <= "01";
                when "10"   =>
                    SEL_0 <= "11";
                    SEL_1 <= "10";
                when others =>
                    SEL_0 <= "00";
                    SEL_1 <= "00";
            end case;
        when DEL_CNT1_1_STATE =>
            SEL_0 <= "01";
            SEL_1 <= "01";
            WEN <= '1';
        when DEL_CNT1_2_STATE =>
            SEL_0 <= "00";
            SEL_1 <= "00";
            WEN <= '0';
        when others =>
            SEL_0 <= "00";
            SEL_1 <= "00";
            WEN <= '1';
    end case;
end process write_fsm_combinatorial;

fifoCount  : process (USER_CLK)
begin
    if (USER_CLK = '1' and USER_CLK'EVENT) then
        if (RESET = '1') then
            wait_fifo_clear_cnt_r <= "11" after 1 ns;
        else if (CurrentState(WAIT_FIFO_CLEAR) = '1') then
                 wait_fifo_clear_cnt_r <=wait_fifo_clear_cnt_r - 1 after 1 ns;
            end if;
        end if;
    end if;
end process fifoCount;

mailboxCode: if (USE_AUTORECOVER ='1') generate
    begin
    mailbox :  process (USER_CLK)
    begin
        if (USER_CLK = '1' and USER_CLK'EVENT) then
            if (RESET = '1') then
                mailbox_r <= "00" after 1 ns;
            else
                if (AF_STATUS = '1' and CurrentState(DEL_CNT1_2) /= '1') then
                    mailbox_r <= mailbox_r + 1 after 1 ns;
                else
                    if (AF_STATUS = '0' and CurrentState(DEL_CNT1_2) = '1') then
                        mailbox_r <= mailbox_r - 1 after 1 ns;
                    else
                        mailbox_r <= mailbox_r after 1 ns;
                    end if;
                end if;
            end if;
        end if;
    end process mailbox;

    mailboxOverflow : process (USER_CLK)
    begin
        if (USER_CLK = '1' and USER_CLK'EVENT) then
             if (RESET = '1') then
                 mailbox_over <= '0' after 1 ns;
             else if (mailbox_over = '0') then
                 if (mailbox_r = "11" and CurrentState(DEL_CNT1_2) /= '1' and AF_STATUS = '1' ) then
                          mailbox_over <= '1' after 1 ns;
                 else
                          mailbox_over <= '0' after 1 ns;
                 end if;
              end if;
            end if;
        end if;
    end process mailboxOverflow;
end generate;

noMailboxCode: if (USE_AUTORECOVER = '0') generate
    begin
    mailboxOverflow : process (USER_CLK)
    begin
        if (USER_CLK = '1' and USER_CLK'EVENT) then
           mailbox_over <= '0';
        end if;
        mailbox_r <= AF_STATUS & AF_STATUS after 1 ns;
    end process mailboxOverflow;
end generate;

prcs_output:process(mailbox_over,CurrentState)
begin
    MAILBOX_OVERFLOW <= mailbox_over ;
    if (CurrentState(WRITE_CNT0) = '1') then
        WFSM_IDLE <= '1';
    else
        WFSM_IDLE <= '0';
    end if;
    if (CurrentState(DEL_CNT0_0) = '1' or CurrentState(DEL_CNT1_0) = '1' ) then
        DELETED_CC <= '1';
    else
        DELETED_CC <= '0';
    end if;
 end process prcs_output;
end architecture write_fsm;

------------------------------------------------------------------------------
--  Module CC_2B_1SKP_RFSM
--
--
--
--  Description: This module performs clock correction in the FPGA
--               fabric instead of depending on the Virtex-5 GTX built-in
--               clock correction capability.
--
--               * Supports a 2-byte data width / 1-byte CC character
--
------------------------------------------------------------------------------
--`timescale 1 ns / 10 ps
library std;
--    use std.textio.all;
library IEEE;
    use IEEE.std_logic_1164.all;
    use IEEE.std_logic_textio.all;
    use IEEE.Std_logic_unsigned.all;
    use IEEE.numeric_std.all;
---entity declarations--------------
entity CC_2B_1SKP_RFSM is
    generic (
     USE_AUTORECOVER  : in  bit := '1'
    );
    port (
        USER_CLK           : in std_logic;
        RESET              : in std_logic;
        AE_STATUS          : in std_logic;
        AE_INIT            : in std_logic;
        BYTE_STATUS        : in std_logic_vector(1 downto 0);
        SEL_0              : out std_logic_vector(1 downto 0);
        SEL_1              : out std_logic_vector(1 downto 0);
        REN                : out std_logic;
        RFSM_IDLE          : out std_logic;
        INSERTED_CC         : out std_logic;
        MAILBOX_OVERFLOW   : out std_logic
    );
 end entity;

ARCHITECTURE read_fsm OF CC_2B_1SKP_RFSM IS

  -- declare the enumeration type


  -- the state vectors
  constant INIT_STATE               :std_logic_vector(9 downto 0)   := "0000000001";
  constant READ_CNT0_STATE         :std_logic_vector(9 downto 0)   := "0000000010";
  constant READ_CNT0_WAIT_STATE    :std_logic_vector(9 downto 0)   := "0000000100";
  constant INS_CNT0_0_STATE         :std_logic_vector(9 downto 0)   := "0000001000";
  constant INS_CNT0_1_STATE         :std_logic_vector(9 downto 0)   := "0000010000";
  constant READ_CNT1_STATE         :std_logic_vector(9 downto 0)   := "0000100000";
  constant INS_CNT1_0_STATE         :std_logic_vector(9 downto 0)   := "0001000000";
  constant INS_CNT1_1_STATE         :std_logic_vector(9 downto 0)   := "0010000000";
  constant INS_CNT1_2_STATE         :std_logic_vector(9 downto 0)   := "0100000000";
  constant WAIT_FIFO_CLEAR_STATE    :std_logic_vector(9 downto 0)   := "1000000000";


  constant INIT               :integer   := 0;
  constant READ_CNT0          :integer   := 1;
  constant READ_CNT0_WAIT     :integer   := 2;
  constant INS_CNT0_0         :integer   := 3;
  constant INS_CNT0_1         :integer   := 4;
  constant READ_CNT1          :integer   := 5;
  constant INS_CNT1_0         :integer   := 6;
  constant INS_CNT1_1         :integer   := 7;
  constant INS_CNT1_2         :integer   := 8;
  constant WAIT_FIFO_CLEAR    :integer   := 9;

  SIGNAL  CurrentState          : std_logic_vector(9 downto 0);
  SIGNAL  status_RCNT0_r        : std_logic_vector(1 downto 0);
  SIGNAL  status_RCNT1_r        : std_logic_vector(1 downto 0);
  SIGNAL  wait_fifo_clear_cnt_r : std_logic_vector(1 downto 0);
  SIGNAL  mailbox_r             : std_logic_vector(1 downto 0);
  SIGNAL  mailbox_over          : std_logic;

 ATTRIBUTE fsm_encoding : string;
 ATTRIBUTE fsm_encoding of CurrentState: signal is "one-hot";

BEGIN

  -- the combinatorial process
read_fsm_state : PROCESS (USER_CLK)
BEGIN
    -- state transitions
    if ( USER_CLK = '1' and USER_CLK'event) then
        if(RESET ='1') then
            CurrentState       <= INIT_STATE after 1 ns;
            status_RCNT0_r     <= "00" after 1 ns;
            status_RCNT1_r     <= "00" after 1 ns;
        else
        CASE CurrentState IS
            when INIT_STATE =>
                if (AE_INIT = '0') then
                    CurrentState <= READ_CNT0_STATE after 1 ns;
                else
                    CurrentState <= INIT_STATE after 1 ns;
                end if;
            when READ_CNT0_STATE =>
                if (mailbox_r /= "00") then
                     CurrentState <= READ_CNT0_WAIT_STATE after 1 ns;
                else
                    CurrentState <= READ_CNT0_STATE after 1 ns;
                end if;
                status_RCNT1_r <= "00" after 1 ns; -- Reset the status flag
            when  READ_CNT0_WAIT_STATE =>
                if (BYTE_STATUS /= "00") then
                    CurrentState <= INS_CNT0_0_STATE after 1 ns;
                    status_RCNT0_r <= BYTE_STATUS after 1 ns;
                else
                    CurrentState <= READ_CNT0_WAIT_STATE after 1 ns;
                    status_RCNT0_r <= "00" after 1 ns ;
                end if;
            when INS_CNT0_0_STATE =>
                 CurrentState <= INS_CNT0_1_STATE after 1 ns;
                      --Special case
            when INS_CNT0_1_STATE =>
                CurrentState <= READ_CNT1_STATE after 1 ns;
            when READ_CNT1_STATE =>
                if (BYTE_STATUS /= "00") then
                    CurrentState <= INS_CNT1_0_STATE after 1 ns;
                    status_RCNT1_r <= BYTE_STATUS after 1 ns;
                else
                    CurrentState <= READ_CNT1_STATE after 1 ns;
                    status_RCNT1_r <=  "00" after 1 ns;
                end if;
            --Special case
            when INS_CNT1_0_STATE =>
                CurrentState <= INS_CNT1_1_STATE after 1 ns;
            when INS_CNT1_1_STATE =>
                CurrentState <=INS_CNT1_2_STATE after 1 ns;
            when INS_CNT1_2_STATE =>
                CurrentState <= WAIT_FIFO_CLEAR_STATE after 1 ns;
                status_RCNT0_r <=  "00" after 1 ns;
            -- State to give the FIFO enough time to de-assert the Almost
            -- Full Flag after the de-assertion of the WREN signal
            when WAIT_FIFO_CLEAR_STATE =>
                if (wait_fifo_clear_cnt_r = "00") then
                    CurrentState <= READ_CNT0_STATE after 1 ns;
                else
                    CurrentState <= WAIT_FIFO_CLEAR_STATE after 1 ns;
                end if;
            when others =>
                CurrentState <= INIT_STATE;
            end case;
        end if;
    end if;
end process read_fsm_state;

read_fsm_combinatorial : process (CurrentState, status_RCNT0_r, status_RCNT1_r)
begin
    case CurrentState is
        when INIT_STATE =>
            SEL_0 <= "00";
            SEL_1 <= "00";
            REN <= '0';
        when READ_CNT0_STATE | READ_CNT0_WAIT_STATE | WAIT_FIFO_CLEAR_STATE =>
            SEL_0 <= "01";
            SEL_1 <= "01";
            REN   <= '1';

        when INS_CNT0_0_STATE =>
            REN <= '1';
            case status_RCNT0_r is
                when "01" =>
                    SEL_0 <= "01";
                    SEL_1 <= "10";
                when "10" =>
                    SEL_0 <= "01";
                    SEL_1 <= "01";
                when others =>
                    SEL_0 <= "00";
                    SEL_1 <= "00";
            end case;
        when INS_CNT0_1_STATE =>
            SEL_0 <= "11";
            SEL_1 <= "10";
            REN   <= '1';
        -- Special case
        when READ_CNT1_STATE =>
            SEL_0 <= "11";
            SEL_1 <= "10";
            REN <=   '1';
        -- Special case
        when INS_CNT1_0_STATE =>
            SEL_0 <= "11";
            SEL_1 <= "10";
            REN <= '0';
        when INS_CNT1_1_STATE =>
            REN <= '1';
            case status_RCNT1_r is
                when "01"  =>
                    SEL_0 <= "00";
                    SEL_1 <= "00";
                when "10"   =>
                    SEL_0 <= "11";
                    SEL_1 <= "00";
                when others =>
                    SEL_0 <= "00";
                    SEL_1 <= "00";
            end case;
        when INS_CNT1_2_STATE =>
            REN <= '1';
            if (status_RCNT1_r = "10" and status_RCNT0_r = "10") then
                 SEL_0 <= "00";
                 SEL_1 <= "00";
             else
                 SEL_0 <= "01";
                 SEL_1 <= "01";
             end if;
        when others =>
            SEL_0 <= "00";
            SEL_1 <= "00";
            REN <= '1';
    end case;
end process read_fsm_combinatorial;

fifoCount  : process (USER_CLK)
begin
    if (USER_CLK = '1' and USER_CLK'EVENT) then
        if (RESET = '1') then
            wait_fifo_clear_cnt_r <= "11" after 1 ns;
        else if (CurrentState(WAIT_FIFO_CLEAR) = '1') then
                if wait_fifo_clear_cnt_r = "00" then
                    wait_fifo_clear_cnt_r <= "11";
                else
                    wait_fifo_clear_cnt_r <= wait_fifo_clear_cnt_r - 1 after 1 ns;
                end if;
            end if;
        end if;
    end if;
end process fifoCount;



generateMail : if (USE_AUTORECOVER = '1') generate
begin
    mailbox :  process (USER_CLK)
    begin
        if (USER_CLK = '1' and USER_CLK'EVENT) then
            if (RESET = '1') then
                mailbox_r <= "00" after 1 ns;
            else
                if (AE_STATUS = '1' and CurrentState(INS_CNT1_2) /= '1') then
                    mailbox_r <= mailbox_r + 1 after 1 ns;
                else
                    if (AE_STATUS = '0' and CurrentState(INS_CNT1_2) = '1') then
                        mailbox_r <= mailbox_r - 1 after 1 ns;
                    else
                        mailbox_r <= mailbox_r after 1 ns;
                    end if;
                end if;
            end if;
        end if;
    end process mailbox;

mailboxOverflow : process (USER_CLK, AE_STATUS)
    begin
        if (USER_CLK = '1' and USER_CLK'EVENT) then
             if (RESET = '1') then
                 mailbox_over <= '0' after 1 ns;
             else if (mailbox_over = '0') then
                     if (mailbox_r = "11" and CurrentState(INS_CNT1_2) /= '1' and AE_STATUS = '1' ) then
                          mailbox_over <= '1' after 1 ns;
                 else
                          mailbox_over <= '0' after 1 ns;
                 end if;
              end if;
            end if;
        end if;
    end process mailboxOverflow;
end generate;


noMailboxCode : if (USE_AUTORECOVER = '0') generate
begin
    mailboxOverflow : process (USER_CLK)
    begin
        if (USER_CLK = '1' and USER_CLK'EVENT) then
             mailbox_over <= '0';
           end if;
         mailbox_r <= AE_STATUS & AE_STATUS;
    end process mailboxOverflow;
end generate;


prcs_output:process(mailbox_over,CurrentState)
begin
    MAILBOX_OVERFLOW <= mailbox_over ;
    if (CurrentState(READ_CNT0) = '1') then
        RFSM_IDLE <= '1';
    else
        RFSM_IDLE <= '0';
    end if;
    if (CurrentState(INS_CNT0_0) ='1' or CurrentState(INS_CNT1_0) = '1' ) then
        INSERTED_CC <= '1';
    else
        INSERTED_CC <= '0';
    end if;
 end process prcs_output;

end architecture read_fsm;

------------------------------------------------------------------------------
--  MODULE CC_2B_1SKP_DATA_PATH
--
-- 
--
--  Description: This module performs clock correction in the FPGA
--               fabric instead of depending on the Virtex-5 GTX built-in
--               clock correction capability.
--
--               * Supports a 2-byte data width / 1-byte CC character
--
------------------------------------------------------------------------------
library IEEE;
    use IEEE.std_logic_1164.all;
    use IEEE.std_logic_textio.all;
    use IEEE.Std_logic_unsigned.all;
    use IEEE.numeric_std.all;

entity CC_2B_1SKP_DATA_PATH is
 port (
    CLK        : in std_logic;
    DATA_IN    : in std_logic_vector(27 downto 0);
    SEL_0      : in std_logic_vector(1  downto 0);
    SEL_1      : in std_logic_vector(1  downto 0);
    RST        : in std_logic;
    DATA_OUT   : out std_logic_vector(27 downto 0)
);
end entity CC_2B_1SKP_DATA_PATH;

architecture dataPath of CC_2B_1SKP_DATA_PATH is




    -- Reg declarations
    signal data_s0_0  : std_logic_vector(13 downto 0) ;--:= 14'h0000;
    signal data_s0_1  : std_logic_vector(13 downto 0) ;--:= 14'h0000;
    signal data_s1_0  : std_logic_vector(13 downto 0) ;--:= 14'h0000;
    signal data_s1_1  : std_logic_vector(13 downto 0) ;--:= 14'h0000;
    signal data_s2_0  : std_logic_vector(13 downto 0) ;--:= 14'h0000;
    signal data_s2_1  : std_logic_vector(13 downto 0) ;--:= 14'h0000;

    signal data_s2_0_d   : std_logic_vector(13 downto 0);
    signal data_s2_1_d   : std_logic_vector(13 downto 0);
    -- Main body of the code
begin
    DATA_OUT   <= (data_s2_1 & data_s2_0 );
    procSel0 : process (SEL_0 , data_s0_0 , data_s0_1 , data_s1_0 , data_s1_1)
    begin
            if SEL_0 = "00" then
                data_s2_0_d <= data_s1_0;
            else
                if SEL_0 = "01" then
                    data_s2_0_d <= data_s0_0;
                else
                    if SEL_0 = "10" then
                        data_s2_0_d <= data_s0_1;
                    else
                        data_s2_0_d <= data_s1_1;
                    end if;
                end if;
            end if;
    end process procSel0;


    procsel1 : process (SEL_1 , data_s0_0 , data_s0_1 , data_s1_0 , data_s1_1)
    begin
        if SEL_1 = "00" then
            data_s2_1_d <= data_s1_1;
        else
            if SEL_1 = "01" then
                data_s2_1_d <= data_s0_1;
            else
                if SEL_1 = "10" then
                    data_s2_1_d <= data_s0_0;
                else
                    data_s2_1_d <= data_s1_0;
                end if;
            end if;
        end if;
    end process procsel1;

    -- Storage registers

   storeregs : process (CLK)
   begin
       if (CLK = '1' and CLK'EVENT ) then
           data_s0_0 <= DATA_IN(13 downto 0) after 1 ns;
           data_s0_1 <= DATA_IN(27 downto 14) after 1 ns;
           data_s1_0 <= data_s0_0 after 1 ns;
           data_s1_1 <= data_s0_1 after 1 ns;
           -- Clear the flops on the last stage of the data path
           if (RST = '1') then
               data_s2_0 <= "00000000000000" after 1 ns;
               data_s2_1 <= "00000000000000" after 1 ns;
           else
               data_s2_0 <= data_s2_0_d after 1 ns;
               data_s2_1 <= data_s2_1_d after 1 ns;
           end if;
       end if;
   end process storeregs;

end architecture;
