<source>

<component>Input buffer for EMAC interface</component>

<authors>
  <author login="polcak_l">Libor Polcak</author>
  <author login="pazdera">Jan Pazdera</author>
	<author login="xmikus03">Martin Mikusek</author>
	<author login="martinek">Tomas Martinek</author>
</authors>

<features>
    <item> Frame length control </item>
    <item> Destination MAC address matching </item>
    <item> Frame check sum control </item>
    <item> 3 speed modes (10, 100 and 1000 Mb/s) </item>
</features>
<!--
<bugs>
</bugs>
-->
<todo>
	<item>HW tests</item>
</todo>

<description>
   This IBUF is based on <ref_comp ref="ibuf">GMII IBUF</ref_comp>
	 The IBUF component complements Xilinx Virtex5 embeded Ethernet MAC layer.
	 Together these components implements receiving part of MAC layer described
   in the IEEE 802.3 standard. Several error checkings are provided upon 
	 each received frame and then its payload is stored or discarded (depends on
	 the optional Error Mask). MAC clients can access and read stored frame
	 payloads via the FrameLink interface.

	 Each payload can be extended by control data which can precede the payload
	 (the header) or follow (the footer). This data are generated by PACODAG
	 component connected by unified interface. IBUF component provides several
	 status information about the incoming frame, which are mainly dedicated for
	 the PACODAG component.
</description>

<interface>
    <generic_map>
        <generic name="ADDR_BASE"   type="integer"  default="none">
            Component base address
        </generic>
        <generic name="DATA_PATHS"  type="integer"  default="none">
            Output data width in bytes
        </generic>
        <generic name="DFIFO_SIZE"  type="integer"  default="none">
            Frame data fifo size
        </generic>
        <generic name="HFIFO_SIZE"  type="integer"  default="none">
            Control data fifo size
        </generic>
        <generic name="MACS"  type="integer"    default="16">
            Number of supported MAC addresses (up to 16)
        </generic>
        <generic name="INBANDFCS"  type="boolean"    default="true">
            Determines whether the frame contains FCS field (true) or not
            (false)
        </generic>
    </generic_map>


    <port_map>
        <divider> Common signals </divider>
        <port name="RESET" dir="in" width="1">
            Design reset
        </port>
        <port name="IBUF_CLK" dir="in" width="1">
            IBUF main clock (clock Framelink interface as well)
        </port>

        <divider> EMAC Interface </divider>
        <port name="IBUFx_RXCLK" dir="in" width="1">
            RX clock
        </port>
        <port name="IBUFx_RXCE" dir="in" width="1">
            RX clock enable
        </port>
        <port name="IBUFx_RXD" dir="in" width="8">
            RX data
        </port>
        <port name="IBUFx_RXDV" dir="in" width="1">
            RX data valid
        </port>
        <port name="IBUFx_RXGOODFRAME" dir="in" width="1">
            EMAC good frame signal
        </port>
        <port name="IBUFx_RXBADFRAME" dir="in" width="1">
            EMAC bad frame signal
        </port>
        <port name="IBUFx_RXSTAT" dir="in" width="7">
            EMAC statistic data
        </port>
        <port name="IBUFx_RXSTATVLD" dir="in" width="1">
            IBUFx_RXSTAT is valid
        </port>

        <divider> PACODAG Interface </divider>
        <port name="IBUFx_CTRL_CLK" dir="out" width="1">
            Clock for PACODAG component
        </port>
        <port name="IBUFx_CTRL_DATA" dir="in" width="DATA_PATH*8">
            Control data
        </port>
        <port name="IBUFx_CTRL_REM" dir="in" width="log2(DATA_PATHS)">
            Specifies the number of valid bytes in the last CTRL_DATA beat; valid only when CTRL_EOP is asserted
        </port>
        <port name="IBUFx_CTRL_SRC_RDY_N" dir="in" width="1">
            Asserted (low) when the input signals from PACODAG are valid
        </port>
        <port name="IBUFx_CTRL_SOP_N" dir="in" width="1">
            Signals the start of the incoming control data. (Active-low, asserted for a single CTRL_CLK cycle) 
        </port>
        <port name="IBUFx_CTRL_EOP_N" dir="in" width="1">
            Signals the end of the incoming control data. (Active-low, asserted for a single CTRL_CLK cycle) 
        </port>
        <port name="IBUFx_CTRL_DST_RDY_N" dir="out" width="1">
            Asserted (low) during clock edges when signals from the PACODAG will be accepted (if CTRL_SRC_RDY_N is also asserted) 
        </port>
        <port name="IBUFx_CTRL_HDR_EN" dir="in" width="1">
            Enables Frame Headers
        </port>
        <port name="IBUFx_CTRL_FTR_EN" dir="in" width="1">
            Enables Frame Footers
        </port>
        <port name="IBUFx_SOP" dir="out" width="1">
            New frame is being received - activate sample unit
        </port>
        <port name="IBUFx_STAT" dir="out" width="RECORD">
            This port is type t_ibuf_emac_stat defined in package ibuf_pkg
        </port>
        <port name="IBUFx_STAT.EMAC_FRAME_BAD" dir="out" width="1">
            Signals whether Xilinx EMAC component marked frame as bad. 0: OK, 1: Error occured
        </port>
        <port name="IBUFx_STAT.PAYLOAD_LEN" dir="out" width="16">
            Length of frame's payload.
        </port>
        <port name="IBUFx_STAT.MAC_CHECK_FAILED" dir="out" width="1">
            Signals whether a MAC check error has occured. 0: OK, 1: Error occured. Note: not supported yet!
        </port>
        <port name="IBUFx_STAT.LEN_BELOW_MIN" dir="out" width="1">
            Signals whether a frame length is below a specified minimum
        </port>
        <port name="IBUFx_STAT.LEN_OVER_MTU" dir="out" width="1">
            Signals whether a frame length is greater than specified MTU
        </port>
        <port name="IBUFx_STAT_DV" dir="out" width="1">
            Data on STAT port are valid for currently received frame - generate PACODAG data for this frame
        </port>

        <divider> Sampling Unit Interface </divider>
        <port name="IBUFx_SAU_ACCEPT" dir="in" width="1">
            Accept the actually incoming frame
        </port>
        <port name="IBUFx_SAU_DV" dir="in" width="1">
            Data on SAU_ACCEPT port are valid
        </port>

        <divider> FrameLink signals </divider>
        <port name="IBUFx_DATA" dir="out" width="DATA_PATHS*8">
            Outgoing data (Ascending bit order)
        </port>
        <port name="IBUFx_DREM" dir="out" width="log2(DATA_PATHS)">
            Specifies the number of valid bytes in the last data beat; valid only when EOP_N is asserted
        </port>
        <port name="IBUFx_SRC_RDY_N" dir="out" width="1">
            Asserted (low) when FrameLink signals from the source are valid
        </port>
        <port name="IBUFx_SOF_N" dir="out" width="1">
            Signals the start of the incoming frame (Active-low, asserted for a single user clock cycle)
        </port>
        <port name="IBUFx_SOP_N" dir="out" width="1">
            Signals the start of the incoming frame (the frame's sub-block) (Active-low, asserted for a single user clock cycle)
        </port>
        <port name="IBUFx_EOF_N" dir="out" width="1">
            Signals the end of the incoming frame (Active-low, asserted for a single user clock cycle)
        </port>
        <port name="IBUFx_EOP_N" dir="out" width="1">
            Signals the end of the incoming frame (the frame's sub-block) (Active-low, asserted for a single user clock cycle)
        </port>
        <port name="IBUFx_DST_RDY_N" dir="in" width="1">
            Asserted (low) during clock edges when signals from the source will be accepted (if SRC_RDY_N is also asserted)
        </port>

        <divider> MI32 interface </divider>
        <port name="MI" dir="inout" width="1">
            MI32 interface
        </port>

    </port_map>

</interface>

<constant>
    <const name="IBUF command: Strobe frame counters" id="IBUFCMD_STROBE_COUNTERS" value="0x01">
        Writing this constant into <ref id="REG_IBUF_CTRL">the command register</ref> will cause that
        the current frame counters' values will be stored into the frame counter registers at the
        same moment.
    </const>

    <const name="IBUF command: Reset frame counters" id="IBUFCMD_RESET_COUNTERS" value="0x02">
        Writing this constant into <ref id="REG_IBUF_CTRL">the command register</ref> will cause that
        the frame counters will be reset.
    </const>

</constant>

<operations>
	<init>

		<it ref="IBUF_SET_ENABLE_STATUS">Disable IBUF</it>

		<it ref="IBUF_SET_ERROR_MASK">Set IBUF error mask</it>

		<it ref="IBUF_SET_ENABLE_STATUS">Enable IBUF</it>

    </init>
    <op name="Enable/Disable IBUF" id="IBUF_SET_ENABLE_STATUS">
        To enable/disable IBUF set/reset 
        <ref id="REG_ENABLE"> IBUF enable register</ref>. Set This register
        to enable IBUF or reset it to disable IBUF.
    </op>

    <op name="Set MAC check mode" id="IBUF_SET_MAC_CHECK">
        To set IBUF MAC check mode store a appropriate value into the 
        <ref id="REG_MAC_CHECK"> IBUF MAC check register</ref>.
        You must <ref id="IBUF_SET_ENABLE_STATUS">disable IBUF first</ref>.
    </op>

    <op name="Set IBUF error mask" id="IBUF_SET_ERROR_MASK">
        To set IBUF error mask store a appropriate value into the 
        <ref id="REG_ERRMASK"> IBUF error mask register</ref>.
        You should <ref id="IBUF_SET_ENABLE_STATUS">disable IBUF first</ref>.
    </op>

    <op name="Set minimal frame length" id="IBUF_SET_MIN_LEN">
        To set the minimal frame length store the appropriate value into the 
        <ref id="REG_MIN_LEN"> IBUF minimum frame len register</ref>. 
        You should <ref id="IBUF_SET_ENABLE_STATUS">disable IBUF first</ref>.
    </op>

    <op name="Set frame MTU" id="IBUF_SET_MTU">
        To set the frame MTU store the appropriate value into the 
        <ref id="REG_MTU"> IBUF frame MTU register</ref>.
        You should <ref id="IBUF_SET_ENABLE_STATUS">disable IBUF first</ref>.
    </op>

    <op name="Sample frame counters" id="IBUF_STROBE_COUNTERS">
        To sample the current frame counters values store 
        <ref id="IBUFCMD_STROBE_COUNTERS"> IBUFCMD_STROBE_COUNTERS</ref> command
        into <ref id="REG_IBUF_CTRL">the command register</ref>.
    </op>

    <op name="Read frame counters' content" id="IBUF_READ_COUNTERS">
        Each IBUF unit contains three frame counters: Total Received Frames Counter (TRFC),
        Correct Frames Counter (CFC) and Discarded Frames Counter (DFC). If the IBUF unit is enabled,
        these counters will have a floating content. For this reason, it is necessary to
        strobe their actual values at the one moment into the frame counter registers. Software driver
        is than able to read those registers. It should hold: TRFC = CFC + DFC or TRFC = CFC + DFC + 1.
    </op>
</operations>

<addr_space id="IBUF" name="Input Buffer" main="yes" size="0x400">
    <instantion ref="IBUF_AS" offset="0x000000">
        IBUF0 address space
    </instantion>
    <instantion ref="IBUF_AS" offset="0x000100">
        IBUF1 address space
    </instantion>
</addr_space>

<addr_space id="IBUF_AS" name="IBUF address space" >
    <reg name="Total Received Frames Counter - low part (TRFCL)" id="CNT_PACKETS_LOW" offset="0x00" access="R" words="0x1">
        <bit_vect bits="32">
            <description_above>
							This is the low part of counter that holds number of all arrived
							frames including those being received at the moment.
							TRFC = CFC + DFC (+ 1).
            </description_above>
            <format>
                <bit from="0" to="31" name="Counter value">
                    Current counter value.
                </bit>
            </format>
        </bit_vect>
    </reg>

    <reg name="Correct Frames Counter - low part (CFCL)" id="CNT_RECV_LOW" offset="0x04" access="R" words="1">
        <bit_vect bits="32">
            <description_above>
							This is the low part of counter that holds number of frames that
							passed sampling and all controls (was found to be correct) and
							are forwarded to the IBUF's output. CFC = TRFC - DFC (- 1).
            </description_above>
            <format>
                <bit from="0" to="31" name="Counter value">
                    Current counter value.
                </bit>
            </format>
        </bit_vect>
    </reg>

    <reg name="Discarded Frames Counter - low part (DFCL)" id="CNT_RECVERR_LOW" offset="0x08" access="R" words="1">
        <bit_vect bits="32">
            <description_above>
							This is the low part of counter taht holds number of frames that
							NOT passed sampling or any control (was found to be NOT
							correct) and are NOT forwarded to the IBUF's output.
							DFC = TRFC - CFC (- 1).
            </description_above>
            <format>
                <bit from="0" to="31" name="Counter value">
                    Current counter value.
                </bit>
            </format>
        </bit_vect>
    </reg>

    <reg name="Counter of frames discarded due to buffer overflow - low part" id="CNT_BUFOVFERR_LOW" offset="0x0C" access="R" words="1">
        <bit_vect bits="32">
            <description_above>
							This is the low part of counter that holds number of frames that
							were discarded due to buffer overflow.
            </description_above>
            <format>
                <bit from="0" to="31" name="Counter value">
                    Current counter value.
                </bit>
            </format>
        </bit_vect>
    </reg>

    <reg name="Total Received Frames Counter - high part (TRFCH)" id="CNT_PACKETS_HIGH" offset="0x10" access="R" words="0x1">
        <bit_vect bits="32">
            <description_above>
							This is the high part of counter that holds number of all arrived
							frames including those being received at the moment.
							TRFC = CFC + DFC (+ 1).
            </description_above>
            <format>
                <bit from="0" to="31" name="Counter value">
                    Current counter value.
                </bit>
            </format>
        </bit_vect>
    </reg>

    <reg name="Correct Frames Counter - high part (CFCH)" id="CNT_RECV_HIGH" offset="0x14" access="R" words="1">
        <bit_vect bits="32">
            <description_above>
							This is the high part of counter that holds number of frames that
							passed sampling and all controls (was found to be correct) and
							are forwarded to the IBUF's output. CFC = TRFC - DFC (- 1).
            </description_above>
            <format>
                <bit from="0" to="31" name="Counter value">
                    Current counter value.
                </bit>
            </format>
        </bit_vect>
    </reg>

    <reg name="Discarded Frames Counter - high part (DFCH)" id="CNT_RECVERR_HIGH" offset="0x18" access="R" words="1">
        <bit_vect bits="32">
            <description_above>
							This is the high part of counter taht holds number of frames that
							NOT passed sampling or any control (was found to be NOT
							correct) and are NOT forwarded to the IBUF's output.
							DFC = TRFC - CFC (- 1).
            </description_above>
            <format>
                <bit from="0" to="31" name="Counter value">
                    Current counter value.
                </bit>
            </format>
        </bit_vect>
    </reg>

    <reg name="Counter of frames discarded due to buffer overflow - high part" id="CNT_BUFOVFERR_HIGH" offset="0x1C" access="R" words="1">
        <bit_vect bits="32">
            <description_above>
							This is the high part of counter that holds number of frames that
							were discarded due to buffer overflow.
            </description_above>
            <format>
                <bit from="0" to="31" name="Counter value">
                    Current counter value.
                </bit>
            </format>
        </bit_vect>
    </reg>

    <reg name="IBUF enable register" id="REG_ENABLE" offset="0x20" access="RW" words="1">
        <bit_vect bits="1">
            <description_above>
                The value stored in this register determines whether the IBUF unit is 
                enabled or not.
            </description_above>
            <format>
                <bit from="0" to="0" name="IBUF enabled">
                    Assert this bit to change the IBUF status to 'enabled'.
                    Clear this bit to change the IBUF status to 'disabled'.
                </bit>
            </format>
            <description_below>
                As soon as the IBUF status is set to 'enabled' the IBUF unit starts working.
            </description_below>
        </bit_vect>
    </reg>

    <reg name="Error mask register" id="REG_ERRMASK" offset="0x24" access="RW" words="1">
        <bit_vect bits="8">
            <description_above>
                This register specifies which controls will be done over incoming frames.
            </description_above>
            <format>
                <bit from="0" to="0" name="RESERVED">
									  Reserved (tied to zero).
                </bit>
                <bit from="1" to="1" name="EMAC_ERROR">
                    This bit signals whether the frames marked by Xilinx EMAC component
										as bad will cause the frame discarding. Assert this bit to allow frame
										discarding. Clear this bit to mask these errors.
                </bit>
                <bit from="2" to="2" name="MIN_LEN_CHECK">
                    This bit enables the minimum frame length check. If the incoming frame length is less than the
                    <ref id="REG_MIN_LEN"> IBUF minimum frame length register</ref>, the frame will be discarded.
                </bit>
                <bit from="3" to="3" name="MTU_CHECK">
                    This bit enables the MTU frame length check. If the incoming frame length is greater than the
                    <ref id="REG_MTU"> IBUF frame MTU register</ref>, the frame will be discarded.
                </bit>
                <bit from="4" to="4" name="MAC_CHECK">
                    This bit enables the frame MAC address check. If the incoming frame destination MAC address doesn't pass the control, 
                    the frame will be discarded. 
                </bit>
                <bit from="5" to="7" name="RESERVED">
                    Reserved (tied to zero).
                </bit>
            </format>
            <description_below>
                The value stored in this register determines which kinds of errors cause the frame
                discarding.
            </description_below>
        </bit_vect>
    </reg>

    <reg name="IBUF status register" id="REG_IBUF_STATUS" offset="0x28" access="RW" words="1">
        <bit_vect bits="8">
            <description_above>
                IBUF status register.
            </description_above>
            <format>
                <bit from="0" to="0" name="PACODAG_OVF">
                    This bit is asserted in case one or more incoming packets
										has not been processed because of the fact that the PACODAG
										component was not ready to generate control data for the packets.
                    Bit reset is performed by writing operation.
                </bit>
                <bit from="1" to="1" name="HFIFO_EMPTY">
                    This bit is asserted in case the HFIFO is empty.
                    This bit is not affected by writing operation.
                </bit>
                <bit from="2" to="2" name="DFIFO_OVF">
                    This bit is asserted in case the DFIFO overflow has occured.
                    Bit reset is performed by writing operation.
                </bit>
                <bit from="3" to="3" name="DFIFO_EMPTY">
                    This bit is asserted in case the DFIFO is empty.
                    This bit is not affected by writing operation.
                </bit>
                <bit from="4" to="5" name="RESERVED">
                    Tied to one.
                </bit>
                <bit from="6" to="10" name="RESERVED">
                    Reserved (tied to zero).
                </bit>
                <bit from="11" to="11" name="BUF_FSM_STATE">
									Debug information
									"0"-S_WAIT, "1"-S_DATA or undefined
                  This bit is not affected by writing operation.
                </bit>
                <bit from="12" to="14" name="FL_FSM_STATE">
									Debug information
									"000"-WAIT_FOR_HEADER, "001"-SEND_HEADER, "010"-WAIT_FOR_DATA,
									"011"-SEND_DATA, "100"-WAIT_FOR_FOOTER, "101"-SEND_FOOTER,
									"110", "111" undefined
                  These bits are not affected by writing operation.
                </bit>
                <bit from="15" to="15" name="RESERVED">
                    Reserved (tied to zero).
                </bit>
            </format>
            <description_below>
            </description_below>
        </bit_vect>
    </reg>

    <reg name="IBUF command register" id="REG_IBUF_CTRL" offset="0x2c" access="W" words="1">
        <bit_vect bits="8">
            <description_above>
                IBUF command register.
            </description_above>
            <format>
                <bit from="0" to="7" name="Command">
                    Write a command into this register.
                </bit>
            </format>
            <description_below>
                See a Software section for Command constats review.
            </description_below>
        </bit_vect>
    </reg>

    <reg name="Minimum frame length allowed" id="REG_MIN_LEN" offset="0x30" access="RW" words="1">
        <bit_vect bits="16">
            <description_above>
                This register specifies the minimal frame length allowed. Default value is 64.
            </description_above>
            <format>
                <bit from="0" to="15" name="Minimal length">
                    The minimal frame length allowed.
                </bit>
            </format>
            <description_below>
                The frame length does NOT include the Preamble length, SFD, padding, FCS and Ending Frame Delimiter.
            </description_below>
        </bit_vect>
    </reg>

    <reg name="Frame MTU" id="REG_MTU" offset="0x34" access="RW" words="1">
        <bit_vect bits="16">
            <description_above>
                This register specifies the maximal frame length allowed (MTU). Default value is 1526.
            </description_above>
            <format>
                <bit from="0" to="15" name="Frame MTU">
                    The maximal frame length allowed (MTU).
                </bit>
            </format>
            <description_below>
                The frame length does NOT include the Preamble length, SFD, padding, FCS and Ending Frame Delimiter.
            </description_below>
        </bit_vect>
    </reg>

    <reg name="MAC address check mode" id="REG_MAC_CHECK" offset="0x38" access="RW" words="1">
        <bit_vect bits="2">
            <description_above>
                This register specifies the mode of MAC address checking.
            </description_above>
            <format>
                <bit from="0" to="1" name="Check mode">
                    The MAC address checking mode.
                </bit>
            </format>
            <description_below>
                <ul>
                    <li>
                        0x0 - MODE 0: All MACs can pass (promiscuous mode). 
                    </li>
                    <li>
                        0x1 - MODE 1: Only frames with valid MAC addresses can pass (see MAC memory). 
                    </li>
                    <li>
                        0x2 - MODE 2: MODE 1 + All brodcast frames can pass. 
                    </li>
                    <li>
                        0x3 - MODE 3: MODE 2 + All multicast frames can pass.
                    </li>
                </ul>
            </description_below>
        </bit_vect>
    </reg>

    <reg name="Memory of available MAC addresses" id="MAC_MEM" offset="0x80" access="RW" words="2">
        <bit_vect bits="49">
            <description_above>
                This memory contains all available MAC addresses for network interface.
            </description_above>
            <format>
                <bit from="0" to="47" name="MAC address">
                    The MAC address.
                </bit>
                <bit from="48" to="48" name="Valid bit">
                    MAC address is valid when asserted.
                </bit>
            </format>
            <description_below>
                !!!IMPORTANT: To write the MAC adress item properly you must first write low 32 bits and then high 16 bits. The MAC memory can be
                accessed by software only when the IBUF is disabled!!!
                Memory can contain up to 16 MAC addresses (it depends on MACS generic). Each MAC address is stored on two address positions. The
                lower address contains the lower 4 bytes and the upper contains the 2 upper bytes and valid bit. Only valid MAC addresses are
                used for matching.
            </description_below>
        </bit_vect>
    </reg>

</addr_space>

<!-- ### doplnit ### --><!--
<sw_body>
</sw_body>-->

<body>
    <h1>Frequency and Resources usage</h1>

	<p>

		<!--Resources usage and max. frequency by Precision-->
		<tab sloupce="ccc">
			<tr>
				<th>Generic settings</th>
				<th>Slices (% of ML555 slices)</th>
				<th>BlockRams (% of ML555 BRAMs)</th>
			</tr>
			<tr>
				<th>DFIFO_SIZE=8192, HFIFO_SIZE=511, MACS = 16, top2_fl16</th>
				<td>564 (7.83%)</td>
				<td>22 (36.67%)</td>
			</tr>
		<nazev>Chip utilization (Precision)</nazev>
		</tab>

		<tab sloupce="ccc">
			<tr>
				<th>Generic settings</th>
				<th>Max.frequency by Precision</th>
				<th>Frequency tested in HW</th>
			</tr>
			<tr>
				<th>DFIFO_SIZE=8192, HFIFO_SIZE=511, MACS = 16, top2_fl16</th>
				<td>206 MHz (IBUFx_RXCLK), 294 MHz (IBUF_CLK)</td>
				<td>None</td>
			</tr>
		<nazev>Maximal frequency (Precision)</nazev>
		</tab>

		<!--Resources usage and max. frequency by XST-->
		<tab sloupce="ccc">
			<tr>
				<th>Generic settings</th>
				<th>Slices (% of ML555 slices)</th>
				<th>BlockRams (% of ML555 BRAMs)</th>
			</tr>
			<tr>
				<th>DFIFO_SIZE=8192, HFIFO_SIZE=511, MACS = 16, top2_fl16</th>
				<td>1151 (15.9%)</td>
				<td>11 (18%)</td>
			</tr>
		<nazev>Chip utilization (XST)</nazev>
		</tab>

		<tab sloupce="ccc">
			<tr>
				<th>Generic settings</th>
				<th>Max.frequency by XST</th>
				<th>Frequency tested in HW</th>
			</tr>
			<tr>
				<th>DFIFO_SIZE=8192, HFIFO_SIZE=511, MACS = 16, top2_fl16</th>
				<td>206 MHz (IBUFx_RXCLK), 294 MHz (IBUF_CLK)</td>
				<td>None</td>
			</tr>
		<nazev>Maximal frequency (XST)</nazev>
		</tab>
  </p>

    <p>
        The IBUF component is composed of three parts: EMAC RX part, Buffers part, MAC Check part and FrameLink decoder part.
    </p>

    <p>
        EMAC RX part searches for SOP and EOP and also process incoming statistic data (but it is
				not used at the moment),
        the frame can be discarded according to the <ref id="REG_ERRMASK"> IBUF error mask register</ref>.
    </p>

    <p>
        The Buffers part provides the frame payload storage. The payload data are transformed from the 8-bit-width to the generic byte-width 
        (power of
        two). Each payload can be extended by control data (header and footer) generated by PACODAG component, so the Buffers part also 
        provides the control Header and Footer storage. 
        The Buffers part performs following frame info computation and checking: the payload length, is below the set minimal
        value, frame length is above the set MTU value. According to the <ref id="REG_ERRMASK"> IBUF error mask register</ref>, the frame
        can be discarded in case of the wrong length. The Payload Buffer size is set by DFIFO_SIZE generic and the Control data Buffer size
        is set by HFIFO_SIZE generic. If the frame is too big that it can't be stored, it will be discarded.
    </p>

    <p>
        The MAC Check part provides frame MAC address matching. The valid MAC addresses for interface are stored in 
        <ref id="MAC_MEM">MAC memory</ref>. There are three modes of MAC checking. 
        <ul>
            <li>
                MODE 0: no checking (promiscuous mode)
            </li>
            <li>
                MODE 1: only frames with MAC addresses matching valid MAC memory items can pass
            </li>
            <li>
                MODE 2: MODE 1 + all broadcast frames can pass
            </li>
            <li>
                MODE 3: MODE 2 + all multicast frames can pass
            </li>
        </ul>
    </p>

    <p>
        FrameLink decoder part performs frame data transmition (incl. optional control data) via the FrameLink interface.
    </p>

    <p>
        Each IBUF unit also provides information about number of total frames received, processed or discarded. So, each IBUF unit 
        contains three frame counters: Total Received Frames Counter (TRFC), Correct Frames Counter (CFC) and Discarded Frames 
        Counter (DFC). The frame can be discarded due to any error-check fail or due to sampling. The error-checks to be performed are
        optional and depends on the value stored in the <ref id="REG_ERRMASK"> IBUF error mask register</ref>.
    </p>

    <p>
        Following table summarize all features causing frame discarding. The column 'Maskable' denotes if the this feature can be masked 
        by <ref id="REG_ERRMASK"> IBUF error mask register</ref>. The column 'Status port' assigns the IBUF status port from the t_ibuf_stat
        record defined in ibuf_pkg package.

        <tab sloupce="lcc">
            <tr>
                <th>Feature</th>
                <th>Maskable?</th>
                <th>Status port</th>
            </tr>
            <tr>
                <td>Frame too big for DFIFO buffer</td>
                <td>No</td>
                <td>N/A</td>
            </tr>
            <tr>
                <td>Frame control data too big for HFIFO buffer</td>
                <td>No</td>
                <td>N/A</td>
            </tr>
            <tr>
                <td>Frame Sampling</td>
                <td>No</td>
                <td>N/A</td>
            </tr>
            <tr>
                <td>Frame is marked as bad by EMAC component (RXBADFRAME)</td>
                <td>Yes</td>
                <td>EMAC_FRAME_BAD</td>
            </tr>
            <tr>
                <td>MAC address check failed</td>
                <td>Yes</td>
                <td>MAC_CHECK_FAILED</td>
            </tr>
            <tr>
                <td>Frame length &lt; reg_min_len</td>
                <td>Yes</td>
                <td>LEN_BELOW_MIN</td>
            </tr>
            <tr>
                <td>Frame length > reg_mtu</td>
                <td>Yes</td>
                <td>LEN_OVER_MTU</td>
            </tr>
            <nazev>Discarding features summarization</nazev>
        </tab>
    </p>

    <h1>Pacodag interface</h1>

    <p>
        As soon as the STAT_DV signal is asserted, generate appropriate control data for the currently received frame. You are allowed to
        generate the control data just for this single frame.
    </p>

</body>

</source>
