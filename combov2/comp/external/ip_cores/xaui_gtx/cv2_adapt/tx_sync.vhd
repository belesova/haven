-------------------------------------------------------------------------------
--   ____  ____ 
--  /   /\/   / 
-- /___/  \  /    Vendor: Xilinx 
-- \   \   \/     Version : 1.6
--  \   \         Application : RocketIO GTX Wizard 
--  /   /         Filename : tx_sync.vhd
-- /___/   /\     Timestamp : 
-- \   \  /  \ 
--  \___\/\___\ 
--
--
-- Module TX_SYNC
-- Generated by Xilinx RocketIO GTX Wizard

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

library work;
use work.all;

entity tx_sync is
  generic (
    PLL_DIVSEL_OUT    : integer := 1;
    CH_SWAP           : boolean := false
  );

  port (
    -- User DRP Interface
    USER_DO             : out std_logic_vector(16-1 downto 0);
    USER_DI             : in  std_logic_vector(16-1 downto 0);
    USER_DADDR          : in  std_logic_vector(7-1 downto 0);
    USER_DEN            : in  std_logic;
    USER_DWE            : in  std_logic;
    USER_DRDY           : out std_logic;

    -- GT DRP Interface
    GT_DO               : out std_logic_vector(16-1 downto 0);  -- connects to DI of GTX_DUAL
    GT_DI               : in  std_logic_vector(16-1 downto 0);  -- connects to DO of GTX_DUAL
    GT_DADDR            : out std_logic_vector(7-1 downto 0);
    GT_DEN              : out std_logic;
    GT_DWE              : out std_logic;
    GT_DRDY             : in  std_logic;

    -- Clocks and Reset
    USER_CLK            : in  std_logic;
    DCLK                : in  std_logic;
    RESET               : in  std_logic;
    RESETDONE           : in  std_logic;

    -- GT side MGT Pass through Signals
    TXENPMAPHASEALIGN   : out std_logic;
    TXPMASETPHASE       : out std_logic;
    TXRESET             : out std_logic;

    -- Sync operations
    SYNC_DONE           : out std_logic;
    RESTART_SYNC        : in  std_logic

);
    attribute X_CORE_INFO : string;
    attribute X_CORE_INFO of tx_sync : entity is "gtxwizard_v1_6, Coregen v11.2";
    
end tx_sync;

architecture rtl of tx_sync is

  ----------------------------------------------------------------------------
  -- Function Declaration 
  ----------------------------------------------------------------------------
  function ExtendString (string_in : string;
                         string_len : integer) 
          return string is 

    variable string_out : string(1 to string_len)
                          := (others => ' '); 

  begin 
    if string_in'length > string_len then 
      string_out := string_in(1 to string_len); 
    else 
      string_out(1 to string_in'length) := string_in; 
    end if;
    return  string_out;
  end ExtendString;

  ----------------------------------------------------------------------------
  -- Constants
  ----------------------------------------------------------------------------
  constant C_DRP_DWIDTH : integer := 16;
  constant C_DRP_AWIDTH : integer := 7;
  constant DLY : time := 1 ns;

  ----------------------------------------------------------------------------
  -- Register Declarations
  ----------------------------------------------------------------------------
  -- USER_CLK domain 

  signal reset_usrclk_r           : std_logic_vector(1 downto 0); -- reset to SYNC FSM
  signal dclk_fsms_rdy_r          : std_logic; -- trigger to move to start_drp state
  signal dclk_fsms_rdy_r2         : std_logic; -- trigger to move to start_drp state
  signal sync_state               : std_logic_vector(6 downto 0);
  signal sync_next_state          : std_logic_vector(6 downto 0);
  signal revert_drp               : std_logic;
  signal start_drp                : std_logic;
  signal start_drp_done_r2        : std_logic;
  signal start_drp_done_r         : std_logic;
  signal txreset_done_r           : std_logic;
  signal revert_drp_done_r2       : std_logic;
  signal revert_drp_done_r        : std_logic;
  signal phase_align_done_r       : std_logic;
  signal sync_counter_r           : std_logic_vector(15 downto 0);
  signal en_phase_align_r         : std_logic;
  signal set_phase_r              : std_logic;   
  signal wait_before_sync_r       : std_logic_vector(5 downto 0);
  signal restart_sync_r2          : std_logic;
  signal restart_sync_r           : std_logic;
  signal resetdone_r              : std_logic;
  signal resetdone_r2             : std_logic;
 
 
  attribute fsm_encoding                  : string;
  attribute fsm_encoding of sync_state    : signal is "one-hot";

  attribute ASYNC_REG                     : string;
  attribute ASYNC_REG of dclk_fsms_rdy_r  : signal is "TRUE";
  attribute ASYNC_REG of start_drp_done_r  : signal is "TRUE";    
  attribute ASYNC_REG of revert_drp_done_r : signal is "TRUE";    
  attribute ASYNC_REG of restart_sync_r    : signal is "TRUE";       
  attribute ASYNC_REG of resetdone_r       : signal is "TRUE";


  -- DCLK domain 

  signal reset_dclk_r             : std_logic_vector(1 downto 0); -- reset to DRP, XD and DB FSMs
  signal user_di_r                : std_logic_vector(C_DRP_DWIDTH-1 downto 0) 
                                    := (others => '0');
  signal user_daddr_r             : std_logic_vector(C_DRP_AWIDTH-1 downto 0) 
                                    := (others => '0');
  signal user_den_r               : std_logic;
  signal user_req                 : std_logic;
  signal user_dwe_r               : std_logic;
  signal xd_req                   : std_logic := '0';
  signal xd_read                  : std_logic := '0';
  signal xd_write                 : std_logic := '0';
  signal xd_drp_done              : std_logic := '0';
  signal xd_wr_wreg               : std_logic_vector(C_DRP_DWIDTH-1 downto 0) 
                                    := (others => '0');
  signal xd_addr_r                : std_logic_vector(C_DRP_AWIDTH-1 downto 0);
  signal gt_drdy_r                : std_logic := '0';
  signal gt_do_r                  : std_logic_vector(C_DRP_DWIDTH-1 downto 0) 
                                    := (others => '0');
  signal db_state                 : std_logic_vector(3 downto 0);
  signal db_next_state            : std_logic_vector(3 downto 0);
  signal drp_state                : std_logic_vector(5 downto 0);
  signal drp_next_state           : std_logic_vector(5 downto 0);
  signal xd_state                 : std_logic_vector(15 downto 0);
  signal xd_next_state            : std_logic_vector(15 downto 0);
  signal revert_drp_r2            : std_logic;
  signal revert_drp_r             : std_logic;
  signal start_drp_r2             : std_logic;
  signal start_drp_r              : std_logic;
  signal user_drdy_i              : std_logic;

  
  attribute fsm_encoding of db_state       : signal is "one-hot";
  attribute fsm_encoding of drp_state      : signal is "one-hot";
  attribute fsm_encoding of xd_state       : signal is "one-hot";

  attribute ASYNC_REG of start_drp_r       : signal is "TRUE";
  attribute ASYNC_REG of revert_drp_r      : signal is "TRUE";


  ----------------------------------------------------------------------------
  -- Wire Declarations
  ----------------------------------------------------------------------------    
  signal gt_do_r_sel                  : std_logic_vector(2 downto 0);
  signal gt_daddr_sel                 : std_logic_vector(2 downto 0);
  signal c_tx_xclk0_addr              : std_logic_vector(C_DRP_AWIDTH-1 downto 0);
  signal c_tx_xclk1_addr              : std_logic_vector(C_DRP_AWIDTH-1 downto 0);
  signal user_sel                     : std_logic;
  signal xd_sel                       : std_logic;
  signal drp_rd                       : std_logic;
  signal drp_wr                       : std_logic;
  signal db_fsm_rdy                   : std_logic;
  signal drp_fsm_rdy                  : std_logic;
  signal xd_fsm_rdy                   : std_logic;
  signal dclk_fsms_rdy                : std_logic;
  signal revert_drp_done              : std_logic;
  signal start_drp_done               : std_logic;
  signal count_setphase_complete_r    : std_logic;
  signal txreset_i                    : std_logic;
    
  ------------------------------------------------------------------------------    
  -- Arbitration FSM - Blocks User DRP Access when SYNC DRP operation 
  -- is in progress
  ------------------------------------------------------------------------------
  constant C_RESET          : std_logic_vector(3 downto 0) := "0001";
  constant C_IDLE           : std_logic_vector(3 downto 0) := "0010";
  constant C_XD_DRP_OP      : std_logic_vector(3 downto 0) := "0100";
  constant C_USER_DRP_OP    : std_logic_vector(3 downto 0) := "1000";

  ------------------------------------------------------------------------------    
  -- DRP FSM
  ------------------------------------------------------------------------------
  constant C_DRP_RESET      : std_logic_vector(5 downto 0) := "000001";
  constant C_DRP_IDLE       : std_logic_vector(5 downto 0) := "000010";
  constant C_DRP_READ       : std_logic_vector(5 downto 0) := "000100";
  constant C_DRP_WRITE      : std_logic_vector(5 downto 0) := "001000";
  constant C_DRP_WAIT       : std_logic_vector(5 downto 0) := "010000";
  constant C_DRP_COMPLETE   : std_logic_vector(5 downto 0) := "100000";

  ------------------------------------------------------------------------------ 
  -- XCLK_SEL DRP FSM
  ------------------------------------------------------------------------------
  constant C_XD_RESET             : std_logic_vector(15 downto 0) 
                                    := "0000000000000001";
  constant C_XD_IDLE              : std_logic_vector(15 downto 0) 
                                    := "0000000000000010";
  constant C_XD_RD_XCLK0_TXUSR    : std_logic_vector(15 downto 0) 
                                    := "0000000000000100";
  constant C_XD_MD_XCLK0_TXUSR    : std_logic_vector(15 downto 0) 
                                    := "0000000000001000";
  constant C_XD_WR_XCLK0_TXUSR    : std_logic_vector(15 downto 0) 
                                    := "0000000000010000";
  constant C_XD_RD_XCLK1_TXUSR    : std_logic_vector(15 downto 0) 
                                    := "0000000000100000";
  constant C_XD_MD_XCLK1_TXUSR    : std_logic_vector(15 downto 0) 
                                    := "0000000001000000";
  constant C_XD_WR_XCLK1_TXUSR    : std_logic_vector(15 downto 0) 
                                    := "0000000010000000";
  constant C_XD_WAIT              : std_logic_vector(15 downto 0) 
                                    := "0000000100000000";
  constant C_XD_RD_XCLK0_TXOUT    : std_logic_vector(15 downto 0) 
                                    := "0000001000000000";
  constant C_XD_MD_XCLK0_TXOUT    : std_logic_vector(15 downto 0) 
                                    := "0000010000000000";
  constant C_XD_WR_XCLK0_TXOUT    : std_logic_vector(15 downto 0) 
                                    := "0000100000000000";
  constant C_XD_RD_XCLK1_TXOUT    : std_logic_vector(15 downto 0) 
                                    := "0001000000000000";
  constant C_XD_MD_XCLK1_TXOUT    : std_logic_vector(15 downto 0) 
                                    := "0010000000000000";
  constant C_XD_WR_XCLK1_TXOUT    : std_logic_vector(15 downto 0) 
                                    := "0100000000000000";
  constant C_XD_DONE              : std_logic_vector(15 downto 0) 
                                    := "1000000000000000";
   
  ------------------------------------------------------------------------------  
  -- SYNC FSM
  ------------------------------------------------------------------------------
  constant C_SYNC_IDLE            : std_logic_vector(6 downto 0) 
                                    := "0000001";    
  constant C_SYNC_START_DRP       : std_logic_vector(6 downto 0) 
                                    := "0000010";
  constant C_SYNC_PHASE_ALIGN     : std_logic_vector(6 downto 0) 
                                    := "0000100";
  constant C_SYNC_REVERT_DRP      : std_logic_vector(6 downto 0) 
                                    := "0001000";
  constant C_SYNC_TXRESET         : std_logic_vector(6 downto 0) 
                                    := "0010000";
  constant C_SYNC_WAIT_RESETDONE  : std_logic_vector(6 downto 0) 
                                    := "0100000";
  constant C_SYNC_DONE            : std_logic_vector(6 downto 0)
                                      := "1000000";
    
  ------------------------------------------------------------------------------   
  -- Make Addresses for GTX0 or GTX1 at compile time
  ------------------------------------------------------------------------------
  constant C_GTX0_TX_XCLK_ADDR    : std_logic_vector(6 downto 0) 
                                    := "0111010";  --3A
  constant C_GTX1_TX_XCLK_ADDR    : std_logic_vector(6 downto 0) 
                                    := "0010101";  --15
begin


GEN_NO_SWAP: if (not CH_SWAP) generate
  c_tx_xclk0_addr    <= C_GTX0_TX_XCLK_ADDR;
  c_tx_xclk1_addr    <= C_GTX1_TX_XCLK_ADDR;
end generate;
  
GEN_SWAP: if (CH_SWAP) generate
  c_tx_xclk0_addr    <= C_GTX1_TX_XCLK_ADDR;
  c_tx_xclk1_addr    <= C_GTX0_TX_XCLK_ADDR;
end generate;

  ------------------------------------------------------------------------------
  -- Sync RESET to USER_CLK and DCLK domain
  ------------------------------------------------------------------------------
  process(DCLK, RESET)
  begin
    if (RESET = '1') then
      reset_dclk_r <= "11";
    elsif (rising_edge(DCLK)) then
      reset_dclk_r <= '0' & reset_dclk_r(1);
    end if;
  end process;

  process(USER_CLK, RESET)
    begin
      if (RESET = '1') then
        reset_usrclk_r <= "11";
      elsif (rising_edge(USER_CLK)) then
        reset_usrclk_r <= '0' & reset_usrclk_r(1);
     end if;
  end process;


  ------------------------------------------------------------------------------
  -- User DRP Transaction Capture Input Registers
  ------------------------------------------------------------------------------
  -- User Data Input
  process (DCLK)
  begin 
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then
        user_di_r <= "0000000000000000";
      elsif (USER_DEN = '1') then 
        user_di_r <= USER_DI;
      end if;
    end if;
  end process;
    
  -- User DRP Address
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then
        user_daddr_r <= "0000000";
      elsif (USER_DEN = '1') then
        user_daddr_r <= USER_DADDR(C_DRP_AWIDTH-1 downto 0);
      end if;
    end if;
  end process;
  
  -- User Data Write Enable
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then
        user_dwe_r <= '0';
      elsif (USER_DEN = '1') then 
        user_dwe_r <= USER_DWE;
      end if;
    end if;
  end process;
  
  -- Register the user_den_r when the user is granted access from the
  -- Arbitration FSM
  process (DCLK)
  begin 
    if (rising_edge(DCLK)) then
      if ( (reset_dclk_r(0) = '1') or (db_state = C_USER_DRP_OP)) then 
        user_den_r <= '0';
      elsif (user_den_r = '0') then
        user_den_r <= USER_DEN;
      end if;
    end if;
  end process;
  
  -- Generate the user request (user_req) signal when the user is not accessing
  -- the same DRP addresses as the deskew Block or when the deskew  
  -- Block is in idle or done states.
  process (DCLK)
  begin 
    if (rising_edge(DCLK)) then
      if ( (reset_dclk_r(0) = '1') or (db_state = C_USER_DRP_OP)) then
        user_req <= '0';
      elsif (not(user_daddr_r = c_tx_xclk0_addr) and
             not(user_daddr_r = c_tx_xclk1_addr)) then
        user_req <= user_den_r;
      elsif((xd_state = C_XD_IDLE) or (xd_state = C_XD_DONE)) then
        user_req <= user_den_r;
      end if;
    end if;
  end process;
    
  -- User Data Output
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if ( (db_state = C_USER_DRP_OP) and (GT_DRDY = '1')) then
        USER_DO <= GT_DI;
      end if;
    end if;
  end process;
  
  -- User Data Ready 
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if ( (reset_dclk_r(0) = '1') or (user_drdy_i = '1')) then
        user_drdy_i <= '0';
      elsif (db_state = C_USER_DRP_OP) then
        user_drdy_i <= GT_DRDY;
      end if;
    end if;
  end process;
  
  USER_DRDY <= user_drdy_i;  
  
  ------------------------------------------------------------------------------  
  -- GT DRP Interface  
  ------------------------------------------------------------------------------    
  -- GT Data Output: the data output is generated either from a XCLK_SEL DRP    
  -- FSM operation, an Auto deskew FSM operation, or a user access.
  
  gt_do_r_sel <= xd_sel & '0' & user_sel;
     
  process (DCLK)
  begin
   if (rising_edge(DCLK)) then
     if (gt_do_r_sel(2) = '1') then
         gt_do_r <= xd_wr_wreg;
     elsif (gt_do_r_sel = "001") then
         gt_do_r <= user_di_r;
     else 
         null;
     end if;
   end if;
  end process;
     
  GT_DO <= gt_do_r;
  
  -- GT DRP Address: the DRP address is generated either from a XCLK_SEL DRP  
  -- FSM operation, or a user access.  DRP address ranges from 0x40 to 0x7F.

  gt_daddr_sel <= xd_sel & '0' & user_sel;
  
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (gt_daddr_sel(2) = '1') then
          GT_DADDR <= xd_addr_r;
        elsif (gt_daddr_sel = "001") then
          GT_DADDR <= user_daddr_r;
        else 
          null;
        end if;
    end if;
  end process;
  
  -- GT Data Enable: the data enable is generated whenever there is a DRP  
  -- Read or a DRP Write
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then
        GT_DEN <= '0';
      else
        if ( (drp_state = C_DRP_IDLE) and 
              ((drp_wr = '1') or (drp_rd = '1')) ) then
          GT_DEN <= '1';
        else
          GT_DEN <= '0';
        end if;
      end if;
    end if;
  end process;
    
  -- GT Data Write Enable
  GT_DWE <= '1' when (drp_state = C_DRP_WRITE) else '0';
  
  -- GT Data Ready
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      gt_drdy_r <= GT_DRDY;
    end if;
  end process;
  
  ------------------------------------------------------------------------------  
  -- SYNC FSM Internal Logic
  -- 1. Trigger DRP operation to change TX_XCLK_SEL to "TXUSR"
  -- 2. Perform Phase Alignment by asserting PMASETPHASE, ENPMAPHASEALIGN ports
  -- 3. Trigger DRP operation to change TX_XCLK_SEL back to "TXOUT"
  -- 4. Apply TXRESET, wait for RESETDONE to go High and assert SYNC_DONE
  ------------------------------------------------------------------------------
  
  dclk_fsms_rdy <= db_fsm_rdy and xd_fsm_rdy and drp_fsm_rdy;
  
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then 
      if (dclk_fsms_rdy = '1') then
        dclk_fsms_rdy_r <= '1';
      else
        dclk_fsms_rdy_r <= '0';
      end if;
    end if;
  end process;
  
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      dclk_fsms_rdy_r2 <= dclk_fsms_rdy_r;
    end if;
  end process;
  
  -- Generate a signal to trigger drp operation of changing XCLK_SEL to TXUSR
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (sync_state = C_SYNC_START_DRP) then 
        start_drp <= '1';  
      else  
        start_drp <= '0';
      end if;
    end if;
  end process;

  -- Capture start_drp_done(DCLK) signal on USER_CLK domain
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (reset_usrclk_r(0) = '1') then
        start_drp_done_r <= '0';
      elsif (start_drp_done = '1') then
        start_drp_done_r <= '1';  
      else
        start_drp_done_r <= '0';
      end if;
    end if;
  end process;
    
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      start_drp_done_r2 <= start_drp_done_r;
    end if;
  end process;
  
  -- Perform Phase Align operations in C_SYNC_PHASE_ALIGN state  
  -- Assert TXENPMAPHASEALIGN in C_SYNC_PHASE_ALIGN state
  -- Once asserted, TXENPMAPHASEALIGN is deasserted only when
  -- the state machine moves back to C_SYNC_IDLE
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if ( (reset_usrclk_r(0) = '1') or (sync_state = C_SYNC_IDLE) ) then
        en_phase_align_r <= '0';
      elsif (sync_state = C_SYNC_PHASE_ALIGN) then
        en_phase_align_r <= '1';
      end if;
    end if;
  end process;
  
  TXENPMAPHASEALIGN <= en_phase_align_r;

  -- Assert set_phase_r in C_SYNC_PHASE ALIGN state after waiting for  
  -- 32 cycles. set_phase_r is deasserted after setphase count is complete
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if ( (reset_usrclk_r(0) = '1') or (en_phase_align_r = '0') ) then
        wait_before_sync_r <= "000000" after DLY;
      elsif (wait_before_sync_r(5) = '0') then
        wait_before_sync_r <= wait_before_sync_r + 1 after DLY;
      end if; 
    end if; 
  end process;
  
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (wait_before_sync_r(5) = '0') then
        set_phase_r <= '0';
      elsif( (count_setphase_complete_r = '0') and (sync_state = C_SYNC_PHASE_ALIGN) ) then
        set_phase_r <= '1';
      else
        set_phase_r <= '0';
      end if; 
    end if;
  end process;
  
  -- Assign PMASETPHASE to set_phase_r  
  TXPMASETPHASE <= set_phase_r;
  
  -- Counter for holding SYNC for SYNC_CYCLES
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if ( (reset_usrclk_r(0) = '1') or not(sync_state = C_SYNC_PHASE_ALIGN) ) then
        sync_counter_r <= "0000000000000000" after DLY;
      elsif (set_phase_r = '1') then 
        sync_counter_r <= sync_counter_r + '1' after DLY;
      end if;
    end if;
  end process;
  
  pll_divsel_out_equals_1 : if (PLL_DIVSEL_OUT = 1) generate
  begin
  -- 8192 cycles of setphase for output divider of 1
    count_setphase_complete_r <= sync_counter_r(13);
  end generate pll_divsel_out_equals_1;
  
  pll_divsel_out_equals_2 : if (PLL_DIVSEL_OUT = 2) generate
  begin
  -- 16384 cycles of setphase for output divider of 2
    count_setphase_complete_r <= sync_counter_r(14);
  end generate pll_divsel_out_equals_2;
  
  pll_divsel_out_equals_4 : if (PLL_DIVSEL_OUT = 4) generate
  begin
  -- 16384 cycles of setphase for output divider of 4
    count_setphase_complete_r <= sync_counter_r(15);
  end generate pll_divsel_out_equals_4;
  
  -- Assert phase_align_done_r when setphase count is complete
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (reset_usrclk_r(0) = '1') then
        phase_align_done_r <= '0';
      else
        phase_align_done_r <= set_phase_r and count_setphase_complete_r;        
      end if;
    end if;
  end process;
  
  -- Generate a signal to trigger drp operation to revert XCLK_SEL back to TXOUT
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (reset_usrclk_r(0) = '1') then 
        revert_drp <= '0';
      elsif (sync_state = C_SYNC_REVERT_DRP) then
        revert_drp <= '1';
      else 
        revert_drp <= '0';
      end if; 
    end if;
  end process;
  
  -- Capture revert_drp_done(DCLK) signal on USER_CLK domain
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (reset_usrclk_r(0) = '1') then
        revert_drp_done_r <= '0';
      elsif(revert_drp_done = '1') then
        revert_drp_done_r <= '1';
      else
        revert_drp_done_r <= '0';
      end if;
    end if;
  end process;
  
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      revert_drp_done_r2 <= revert_drp_done_r;
    end if;
  end process;
    
  -- Assert txreset_i in C_SYNC_TXRESET state
  txreset_i <= '1' when (sync_state = C_SYNC_TXRESET) else '0';
  
  -- Register txreset_i on USER_CLK
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then 
      TXRESET <= txreset_i;
    end if;    
  end process;  
  
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (reset_usrclk_r(0) = '1') then 
        txreset_done_r <= '0';
      elsif ( (sync_state = C_SYNC_TXRESET) and (resetdone_r2 = '0') ) then
        txreset_done_r <= '1';
      else
        txreset_done_r <= '0';
      end if;
    end if;
  end process;
  
  -- Capture RESETDONE on USER_CLK 
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (RESETDONE = '1') then
        resetdone_r <= '1';
      else 
        resetdone_r <= '0';
      end if;
    end if;
  end process;
  
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      resetdone_r2 <= resetdone_r;
    end if;
  end process; 
  
  -- Capture RESTART_SYNC on USER_CLK
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (RESTART_SYNC = '1') then 
        restart_sync_r <= '1';
      else
        restart_sync_r <= '0';
      end if;
    end if;
  end process; 
          
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      restart_sync_r2 <= restart_sync_r;
    end if;
  end process;
  
  SYNC_DONE <= '1' when (sync_state = C_SYNC_DONE) else '0';
  
  ------------------------------------------------------------------------------  
  -- SYNC FSM  
  ------------------------------------------------------------------------------
 
  process (USER_CLK)
  begin
    if (rising_edge(USER_CLK)) then
      if (reset_usrclk_r(0) = '1') then 
        sync_state <= C_SYNC_IDLE;
      else 
        sync_state <= sync_next_state;
      end if; 
    end if;
  end process;
  
  process (sync_state, dclk_fsms_rdy_r2, start_drp_done_r2, phase_align_done_r, 
            revert_drp_done_r2, txreset_done_r, resetdone_r2, restart_sync_r2) 
    variable sync_fsm_name : string(1 to 25);
  begin
    case sync_state is

      when C_SYNC_IDLE =>

        if (dclk_fsms_rdy_r2 = '0') then
          sync_next_state <= C_SYNC_IDLE;
        else
          sync_next_state <= C_SYNC_START_DRP;
        end if;

        sync_fsm_name := ExtendString("C_SYNC_IDLE", 25);
 
      when C_SYNC_START_DRP =>

        if (start_drp_done_r2 = '0') then
          sync_next_state <= C_SYNC_START_DRP;
        else
          sync_next_state <= C_SYNC_PHASE_ALIGN;
        end if;

        sync_fsm_name := ExtendString("C_SYNC_START_DRP", 25);
        
      when C_SYNC_PHASE_ALIGN =>

        if (phase_align_done_r = '0') then
          sync_next_state <= C_SYNC_PHASE_ALIGN;
        else
          sync_next_state <= C_SYNC_REVERT_DRP;
        end if;

        sync_fsm_name := ExtendString("C_SYNC_PHASE_ALIGN", 25);       
        
      when C_SYNC_REVERT_DRP =>

        if (revert_drp_done_r2 = '0') then
          sync_next_state <= C_SYNC_REVERT_DRP;
        else
          sync_next_state <= C_SYNC_TXRESET;
        end if;

        sync_fsm_name := ExtendString("C_SYNC_REVERT_DRP", 25);           
        
      when C_SYNC_TXRESET =>

        if (txreset_done_r = '0') then
          sync_next_state <= C_SYNC_TXRESET;
        else
          sync_next_state <= C_SYNC_WAIT_RESETDONE;
        end if;

        sync_fsm_name := ExtendString("C_SYNC_TXRESET", 25);         
        
      when C_SYNC_WAIT_RESETDONE =>

        if (resetdone_r2 = '0') then
          sync_next_state <= C_SYNC_WAIT_RESETDONE;
        else
          sync_next_state <= C_SYNC_DONE;
        end if;

        sync_fsm_name := ExtendString("C_SYNC_WAIT_RESETDONE", 25);         
        
      when C_SYNC_DONE =>

        if (restart_sync_r2 = '0') then
          sync_next_state <= C_SYNC_DONE;
        else
          sync_next_state <= C_SYNC_IDLE;
        end if;

        sync_fsm_name := ExtendString("C_SYNC_DONE", 25);
        
      when others =>

        sync_next_state <= C_SYNC_IDLE;
        sync_fsm_name := ExtendString("default", 25);
        
    end case;
  end process;
  
  ------------------------------------------------------------------------------  
  -- deskew Block Internal Logic:  The different select signals are
  -- generated for a user DRP operations as well as internal deskew Block
  -- accesses.
  ------------------------------------------------------------------------------
  
  xd_sel <= '1' when (db_state = C_XD_DRP_OP) else '0';
  user_sel <= '1' when (db_state = C_USER_DRP_OP) else '0';
  db_fsm_rdy <= '0' when (db_state = C_RESET) else '1';
  
  ------------------------------------------------------------------------------  
  -- deskew Block (DB) FSM
  ------------------------------------------------------------------------------

  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then 
        db_state <= C_RESET;
      else 
        db_state <= db_next_state;
      end if; 
    end if;
  end process;

  process (db_state, xd_req, user_req, gt_drdy_r) 
    variable db_fsm_name : string(1 to 25);
  begin
    case db_state is

      when C_RESET =>
      
        db_next_state <= C_IDLE;
        
        db_fsm_name := ExtendString("C_RESET", 25);
 
      when C_IDLE =>
      
        if (xd_req = '1') then
          db_next_state <= C_XD_DRP_OP;
        elsif (user_req = '1') then
          db_next_state <= C_USER_DRP_OP;
        else 
          db_next_state <= C_IDLE; 
        end if;
      
        db_fsm_name := ExtendString("C_IDLE", 25);
      
      when C_XD_DRP_OP =>

        if (gt_drdy_r = '0') then
          db_next_state <= C_XD_DRP_OP;
        else 
          db_next_state <= C_IDLE; 
        end if;
            
        db_fsm_name := ExtendString("C_XD_DRP_OP", 25);
      
      when C_USER_DRP_OP =>

        if (gt_drdy_r = '0') then
          db_next_state <= C_USER_DRP_OP;
        else 
          db_next_state <= C_IDLE; 
        end if;
                  
        db_fsm_name := ExtendString("C_USER_DRP_OP", 25);
        
      when others =>

        db_next_state <= C_IDLE;
        db_fsm_name := ExtendString("default", 25);
             
     end case;
   end process;
   
  ------------------------------------------------------------------------------   
  -- XCLK_SEL DRP Block Internal Logic
  ------------------------------------------------------------------------------
  
  -- Request for DRP operation  
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if ( (xd_state = C_XD_IDLE) or (xd_drp_done = '1') ) then 
        xd_req <= '0';
      else 
        xd_req <= xd_read or xd_write;
      end if; 
    end if;
  end process;
  
  -- Indicates DRP Read
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if ( (xd_state = C_XD_IDLE) or (xd_drp_done = '1') ) then 
        xd_read <= '0';
      else
        if ( (xd_state = C_XD_RD_XCLK0_TXUSR) or
             (xd_state = C_XD_RD_XCLK1_TXUSR) or 
             (xd_state = C_XD_RD_XCLK0_TXOUT) or
             (xd_state = C_XD_RD_XCLK1_TXOUT) ) then 
          xd_read <= '1';
        else 
          xd_read <= '0';
        end if;
      end if;
    end if;
  end process;
  
  -- Indicates Detect DRP Write
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if ( (xd_state = C_XD_IDLE) or (xd_drp_done = '1') ) then 
        xd_write <= '0';
      else
        if ( (xd_state = C_XD_WR_XCLK0_TXUSR) or
             (xd_state = C_XD_WR_XCLK1_TXUSR) or
             (xd_state = C_XD_WR_XCLK0_TXOUT) or
             (xd_state = C_XD_WR_XCLK1_TXOUT) ) then
          xd_write <= '1';
        else
          xd_write <= '0';
        end if;
      end if;
    end if;
  end process;
  
  -- Detect DRP Write Working Register
  -- TODO: Add check for txrx_invert bits as well
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if ( (db_state = C_XD_DRP_OP) and (xd_read = '1') and (GT_DRDY = '1') ) then 
        xd_wr_wreg <= GT_DI;
      else
        case xd_state is
        
          when C_XD_MD_XCLK0_TXUSR =>
            xd_wr_wreg <= xd_wr_wreg(15 downto 9) & '1' & xd_wr_wreg(7 downto 0);
          when C_XD_MD_XCLK1_TXUSR =>
            xd_wr_wreg <= xd_wr_wreg(15 downto 8) & '1' & xd_wr_wreg(6 downto 0);   
          when C_XD_MD_XCLK0_TXOUT =>
            xd_wr_wreg <= xd_wr_wreg(15 downto 9) & '0' & xd_wr_wreg(7 downto 0);
          when C_XD_MD_XCLK1_TXOUT =>
            xd_wr_wreg <= xd_wr_wreg(15 downto 8) & '0' & xd_wr_wreg(6 downto 0);
          when others =>
            null;
        end case;
      end if;
    end if;
  end process;
  
  -- Generate DRP Addresses
  process (xd_state)
  begin
    case xd_state is
      when C_XD_RD_XCLK0_TXUSR =>
        xd_addr_r <= c_tx_xclk0_addr;
      when C_XD_WR_XCLK0_TXUSR =>
        xd_addr_r <= c_tx_xclk0_addr;
      when C_XD_RD_XCLK0_TXOUT =>
        xd_addr_r <= c_tx_xclk0_addr;
      when C_XD_WR_XCLK0_TXOUT =>
        xd_addr_r <= c_tx_xclk0_addr;
      when C_XD_RD_XCLK1_TXUSR =>
        xd_addr_r <= c_tx_xclk1_addr;
      when C_XD_WR_XCLK1_TXUSR =>
        xd_addr_r <= c_tx_xclk1_addr;    
      when C_XD_RD_XCLK1_TXOUT =>
        xd_addr_r <= c_tx_xclk1_addr;
      when C_XD_WR_XCLK1_TXOUT =>
        xd_addr_r <= c_tx_xclk1_addr;
      when others =>
        xd_addr_r <= c_tx_xclk0_addr;
    end case;
  end process;
  
  -- Assert DRP DONE when DRP Operation is Complete
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if ( (GT_DRDY = '1') and (db_state = C_XD_DRP_OP) ) then
        xd_drp_done <= '1';
      else 
        xd_drp_done <= '0';      
      end if;
    end if;
  end process;
  
  -- Assert xd_fsm_rdy when xd_state is not C_XD_RESET  
  xd_fsm_rdy <= '0' when (xd_state = C_XD_RESET) else '1';
  
  -- Generate a start_drp_r2 on DCLK domain from start_drp(USER_CLK)
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then 
        start_drp_r <= '0';
      elsif (start_drp = '1') then
        start_drp_r <= '1';
      else
        start_drp_r <= '0';
      end if;
    end if;
  end process;
  
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      start_drp_r2 <= start_drp_r;
    end if;
  end process;
  
  -- Assert start_drp_done when xd_state is C_XD_WAIT
  start_drp_done <= '1' when (xd_state = C_XD_WAIT) else '0';
  
  -- Generate a revert_drp_r2 on DCLK domain from revert_drp(USER_CLK)
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then
        revert_drp_r <= '0';
      elsif (revert_drp = '1') then
        revert_drp_r <= '1';
      else
        revert_drp_r <= '0';
      end if;
    end if;
  end process;
  
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      revert_drp_r2 <= revert_drp_r;
    end if;
  end process;

  revert_drp_done <= '1' when (xd_state = C_XD_DONE) else '0'; 
  
  ------------------------------------------------------------------------------
  -- XCLK_SEL DRP FSM:  The XD FSM is triggered by the SYNC FSM
  ------------------------------------------------------------------------------
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then
        xd_state <= C_XD_RESET;
      else
        xd_state <= xd_next_state;
      end if;
    end if;
  end process;
  
  process (xd_state, start_drp_r2, xd_drp_done, revert_drp_r2)
    variable xd_fsm_name : string(1 to 25);  
  begin
    case xd_state is
      
      when C_XD_RESET =>
      
        xd_next_state <= C_XD_IDLE;
        xd_fsm_name := ExtendString("C_XD_RESET", 25);
        
      when C_XD_IDLE =>
      
        if (start_drp_r2 = '1') then
          xd_next_state <= C_XD_RD_XCLK0_TXUSR;
        else
          xd_next_state <= C_XD_IDLE;
        end if;
          
        xd_fsm_name := ExtendString("C_XD_IDLE", 25);
        
      when C_XD_RD_XCLK0_TXUSR =>

        if (xd_drp_done = '0') then
          xd_next_state <= C_XD_RD_XCLK0_TXUSR;
        else
          xd_next_state <= C_XD_MD_XCLK0_TXUSR;
        end if;

        xd_fsm_name := ExtendString("C_XD_RD_XCLK0_TXUSR", 25);
        
      when C_XD_MD_XCLK0_TXUSR =>

        xd_next_state <= C_XD_WR_XCLK0_TXUSR;
        xd_fsm_name := ExtendString("C_XD_MD_XCLK0_TXUSR", 25);
        
      when C_XD_WR_XCLK0_TXUSR =>

        if (xd_drp_done = '0') then
          xd_next_state <= C_XD_WR_XCLK0_TXUSR;
        else
          xd_next_state <= C_XD_RD_XCLK1_TXUSR;
        end if;

        xd_fsm_name := ExtendString("C_XD_WR_XCLK0_TXUSR", 25);
        
      when C_XD_RD_XCLK1_TXUSR =>

        if (xd_drp_done = '0') then
          xd_next_state <= C_XD_RD_XCLK1_TXUSR;
        else
          xd_next_state <= C_XD_MD_XCLK1_TXUSR;
        end if;

        xd_fsm_name := ExtendString("C_XD_RD_XCLK1_TXUSR", 25);
      
      when C_XD_MD_XCLK1_TXUSR =>

        xd_next_state <= C_XD_WR_XCLK1_TXUSR;
        xd_fsm_name := ExtendString("C_XD_MD_XCLK1_TXUSR", 25);
        
      when C_XD_WR_XCLK1_TXUSR =>

        if (xd_drp_done = '0') then
          xd_next_state <= C_XD_WR_XCLK1_TXUSR;
        else
          xd_next_state <= C_XD_WAIT;
        end if;

        xd_fsm_name := ExtendString("C_XD_WR_XCLK1_TXUSR", 25);

      when C_XD_WAIT =>

        if (revert_drp_r2 = '0') then
          xd_next_state <= C_XD_WAIT;
        else
          xd_next_state <= C_XD_RD_XCLK0_TXOUT;
        end if;

        xd_fsm_name := ExtendString("C_XD_WAIT", 25);
        
      when C_XD_RD_XCLK0_TXOUT =>

        if (xd_drp_done = '0') then
          xd_next_state <= C_XD_RD_XCLK0_TXOUT;
        else
          xd_next_state <= C_XD_MD_XCLK0_TXOUT;
        end if;

        xd_fsm_name := ExtendString("C_XD_RD_XCLK0_TXOUT", 25);
        
      when C_XD_MD_XCLK0_TXOUT =>

        xd_next_state <= C_XD_WR_XCLK0_TXOUT;
        xd_fsm_name := ExtendString("C_XD_MD_XCLK0_TXOUT", 25);
        
      when C_XD_WR_XCLK0_TXOUT =>

        if (xd_drp_done = '0') then
          xd_next_state <= C_XD_WR_XCLK0_TXOUT;
        else
          xd_next_state <= C_XD_RD_XCLK1_TXOUT;
        end if;

        xd_fsm_name := ExtendString("C_XD_WR_XCLK0_TXOUT", 25);
        
      when C_XD_RD_XCLK1_TXOUT =>

        if (xd_drp_done = '0') then
          xd_next_state <= C_XD_RD_XCLK1_TXOUT;
        else
          xd_next_state <= C_XD_MD_XCLK1_TXOUT;
        end if;

        xd_fsm_name := ExtendString("C_XD_RD_XCLK1_TXOUT", 25);
        
      when C_XD_MD_XCLK1_TXOUT =>

        xd_next_state <= C_XD_WR_XCLK1_TXOUT;
        xd_fsm_name := ExtendString("C_XD_MD_XCLK1_TXOUT", 25);
        
      when C_XD_WR_XCLK1_TXOUT =>

        if (xd_drp_done = '0') then
          xd_next_state <= C_XD_WR_XCLK1_TXOUT;
        else
          xd_next_state <= C_XD_DONE;
        end if;

        xd_fsm_name := ExtendString("C_XD_WR_XCLK1_TXOUT", 25);        
        
      when C_XD_DONE =>

        if (revert_drp_r2 = '0') then
          xd_next_state <= C_XD_IDLE;
        else
          xd_next_state <= C_XD_DONE;
        end if;

        xd_fsm_name := ExtendString("C_XD_DONE", 25); 
        
      when others =>

        xd_next_state <= C_XD_IDLE;
        xd_fsm_name := ExtendString("default", 25);
             
     end case;
   end process;
   
  ------------------------------------------------------------------------------   
  -- DRP Read/Write FSM      
  ------------------------------------------------------------------------------ 
  -- Generate a read signal for the DRP
  drp_rd <= '1' when  ( ((db_state = C_XD_DRP_OP) and (xd_read = '1')) or
                        ((db_state = C_USER_DRP_OP) and (user_dwe_r = '0')) )
            else '0';
  
  -- Generate a write signal for the DRP
  drp_wr <= '1' when  ( ((db_state = C_XD_DRP_OP) and (xd_write = '1')) or
                        ((db_state = C_USER_DRP_OP) and (user_dwe_r = '1')) )
            else '0';
            
  drp_fsm_rdy <= '0' when (drp_state = C_DRP_RESET) else '1';
 
  process (DCLK)
  begin
    if (rising_edge(DCLK)) then
      if (reset_dclk_r(0) = '1') then
        drp_state <= C_DRP_RESET;
      else 
        drp_state <= drp_next_state;
      end if;
    end if;
   end process;
  
  process (drp_state, drp_wr, drp_rd, gt_drdy_r)
    variable drp_fsm_name : string(1 to 25);  
  begin
    case drp_state is
      
      when C_DRP_RESET =>
      
        drp_next_state <= C_DRP_IDLE;
        drp_fsm_name := ExtendString("C_DRP_RESET", 25);
        
      when C_DRP_IDLE =>
      
        if (drp_wr = '1') then
          drp_next_state <= C_DRP_WRITE;
        else
          if (drp_rd = '1') then
            drp_next_state <= C_DRP_READ; 
          else
            drp_next_state <= C_DRP_IDLE;
          end if;
        end if;
      
        drp_fsm_name := ExtendString("C_DRP_IDLE", 25); 
      
      when C_DRP_READ =>
      
        drp_next_state <= C_DRP_WAIT;
        drp_fsm_name := ExtendString("C_DRP_READ", 25);
        
      when C_DRP_WRITE =>
      
        drp_next_state <= C_DRP_WAIT;
        drp_fsm_name := ExtendString("C_DRP_WRITE", 25); 
             
      when C_DRP_WAIT =>
      
        if (gt_drdy_r = '0') then
          drp_next_state <= C_DRP_WAIT;
        else
          drp_next_state <= C_DRP_COMPLETE;
        end if;
      
        drp_fsm_name := ExtendString("C_DRP_WAIT", 25);

      when C_DRP_COMPLETE =>
      
        drp_next_state <= C_DRP_IDLE;
        drp_fsm_name := ExtendString("C_DRP_COMPLETE", 25);
     
      when others =>

        drp_next_state <= C_DRP_IDLE;
        drp_fsm_name := ExtendString("default", 25);

     end case;
  end process;

end rtl;
