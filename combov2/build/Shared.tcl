
# ---------------------- Common procedures ----------------------------
# String Generation
proc GenStr {NUM CH} {
   set str $CH
   for {set i 0} {$i<$NUM} {incr i} {
      set str [format "%s%s" $str $CH]
   }
   return $str
}

# Print Label
proc PrintLabel {LABEL} {
   set lines [GenStr 70 "-"]
   set space [GenStr [expr [expr 65 - [string length $LABEL]] / 2] " "]
   puts "$lines\n$space $LABEL\n$lines"
}

# Make PATH as simple as possible by iterative substitutions of
# /dir_name/../ by /
proc SimplPath {PATH} {
   set original $PATH

   set FIRST_CHAR [ string index $PATH 0 ]
   if { $FIRST_CHAR == "/" } {
      set FULLPATH "$PATH"
   } else {
      set FULLPATH [join [list [ pwd ] "$PATH"] "/" ]
   }

   # Subsitute /./ or // by /
   set RE "/\./|//"
   while {[regexp $RE $FULLPATH]} {
      regsub $RE $FULLPATH "/" FULLPATH
   }

   # Regular expression:
   # / followed by
   # any number of non-slash characters
   # followed by one non-slash non-dot character
   # followed by any number of non-slash characters
   # followed by / followed by .. followed by /
   set RE "/\[^/\]*\[^/.\]\[^/\]*/\\.\\./"

   while {[regexp $RE $FULLPATH]} {
      regsub $RE $FULLPATH "/" FULLPATH
   }


   return $FULLPATH
}


# Process all macros in the file and write result to another file.
# Currently supported macros:
# -- MACRO INSERT MyFunc
# inserts contents of appropriate file (matched in the SUBSTS list) from tag 
# -- MACRO START 
# to the end
proc ProcessMacros {SRC DST SUBSTS} {
   upvar 1 $SUBSTS SUBSTS_VAR

   set srch [open $SRC]
   set dsth [open $DST w]

   puts $dsth "-- This file was generated by translation system."
   puts $dsth "-- Do not commit it into source code archive.\n"

   while {[gets $srch line] >= 0} {
      # For each line in the source file

      set RE "-- MACRO INSERT *"
      if {[regexp -- $RE $line]} {
         # If there is any macro on this line
         set found 0
         foreach i $SUBSTS {
            # For each item in the list of substitutions
            set fname [lindex $i 0]
            set RE "-- MACRO INSERT $fname*"

            if {[regexp -- $RE $line]} {
               # If we found correct substitution
               set found 1
               set start 0
               set fname [lindex $i 1]
               set funh [open $fname]
               while {[gets $funh substline] >= 0} {
                  if {$start == 1} {
                     puts $dsth $substline
                  }

                  set RE "-- MACRO START*"
                  if {[regexp -- $RE $substline]} {
                     set start 1
                  }
               }
               if {$start == 0} {
                  puts "Warning: This macro has not been expanded:"
                  puts $line
                  puts $dsth $line
                  puts $dsth "-- $fname does not contain MACRO START macro!"
               }
               close $funh
            } 
         }
         if {$found == 0} {
            puts "Warning: This macro has not been expanded:"
            puts $line
            puts $dsth $line
            puts $dsth "-- Cannot find this macro in the list of substitutions!"
         }
      } else {
         # If there is no macro
         puts $dsth $line
      }
   }

   close $srch
   close $dsth
}

# ------------------------ ApplyToComponent -----------------------------

# Apply Command To Module List
proc ApplyToMods {MODULE COMMAND FILES} {
   upvar 1 $FILES FILES_VAR
   set eval_cmd "$COMMAND \$i"

   foreach i $MODULE {
      if { [ llength $i ] == 1 } {
         set i [SimplPath $i]
      } else {
         set i [list [lindex $i 0] [SimplPath [lindex $i 1]]]
      }
      if { [lsearch $FILES_VAR $i] == -1 } {
         eval $eval_cmd
         set FILES_VAR [linsert $FILES_VAR 0 $i]
      } else {
#puts "------------------ Doubled file ------------------"
#puts $i
      }
   }
}

# Apply Command To Component List
proc ApplyToComponents {COMPONENTS COMMAND FILES SV_LIBS {LEVEL "1"} } {
   upvar 1 $FILES FILES_VAR
   upvar 1 $SV_LIBS SV_LIBS_VAR
   foreach i $COMPONENTS {
      ApplyToComponent $i $COMMAND FILES_VAR SV_LIBS_VAR $LEVEL
   }
}

# Apply Commnad To Single Component
proc ApplyToComponent {COMPONENT COMMAND FILES SV_LIBS LEVEL} {
   upvar 1 $FILES FILES_VAR
   upvar 1 $SV_LIBS SV_LIBS_VAR

   # variable setting -----------------------------
   set mod_str          [lindex $COMPONENT 0]
   set ENTITY           [lindex $COMPONENT 0]
   set mod_base         [lindex $COMPONENT 1]
   set ENTITY_BASE      [lindex $COMPONENT 1]
   set ENTITY_MODFILE   "$ENTITY_BASE/Modules.tcl"
   set mod_base_str     [format "%s%s" $mod_str "_BASE"]
   set $mod_base_str    $mod_base
   set $mod_str         [lindex $COMPONENT 2]
   set ARCHGRP          [lindex $COMPONENT 2]

   # label printing ------------------------------
   if { $LEVEL == 1 } {
      PrintLabel $mod_str
   }

   # script execution ----------------------------
   set MOD ""
   set SV_LIB ""
   set COMPONENTS ""
   set PACKAGES ""

   global env
   if {[info exists env(SECOND_PASS)]} {
      # Environment can disable compilation of additional stuff in Modules.tcl
      set SECOND_PASS $env(SECOND_PASS)
   }

   source $mod_base/Modules.tcl

   # collect values of SV_LIB
   foreach i $SV_LIB {
      set SV_LIBS_VAR [linsert $SV_LIBS_VAR 0 $i]
   }

   # apply command to local packages -------------
   ApplyToMods $PACKAGES $COMMAND FILES_VAR

   # apply command to subcomponents --------------
   if { $COMPONENTS != "" } {
      ApplyToComponents $COMPONENTS $COMMAND FILES_VAR SV_LIBS_VAR [expr $LEVEL + 1]
   }

   # apply command to local modules --------------
   ApplyToMods $MOD $COMMAND FILES_VAR
}

# ------------------------ ApplyToInstances ----------------------------

# Apply Command To Instances within Component List
proc ApplyToInstances {COMPONENTS COMMAND PARAMS {PATH ""} {LEVEL "1"} } {
   upvar 1 $PARAMS param_array
   foreach i $COMPONENTS {
      ApplyToInstance $i $COMMAND param_array $PATH $LEVEL
   }
}

# Apply Commnad To Instances within Single Component
proc ApplyToInstance {COMPONENT COMMAND PARAMS PATH LEVEL} {
   upvar 1 $PARAMS param_array
   # variable setting -----------------------------
   set mod_str        [lindex $COMPONENT 0]
   set ENTITY         [lindex $COMPONENT 0]
   set mod_base       [lindex $COMPONENT 1]
   set ENTITY_BASE    [lindex $COMPONENT 1]
   set ENTITY_MODFILE "$ENTITY_BASE/Modules.tcl"
   set mod_base_str   [format "%s%s" $mod_str "_BASE"]
   set $mod_base_str  $mod_base
   set $mod_str       [lindex $COMPONENT 2]
   set ARCHGRP        [lindex $COMPONENT 2]
   if { [llength $COMPONENT] == 4 } {
      set inst_list [lindex $COMPONENT 3]
   } else {
      set inst_list ""
   }

   # label printing ------------------------------
   if { $LEVEL == 1 } {
      PrintLabel $mod_str
   }

   # script execution ----------------------------
   set MOD ""
   set SV_LIB ""
   set COMPONENTS ""
   set PACKAGES ""
   
   # Disable compilation of additional stuff from Modules.tcl
   set SECOND_PASS "1"

   source $mod_base/Modules.tcl

   # get list of instances  ----------------------
   if { $inst_list != "" } {
       foreach i $inst_list {
          # set instance path and architecture
          if { $LEVEL == 1 } {
            set inst_path [lindex $i 0]
          } else {
            set inst_path [format "%s.%s" $PATH [lindex $i 0]]
          }
          set inst_arch [lindex $i 1]

          # apply procedure to current instance 
          set eval_cmd "$COMMAND $mod_base $mod_str $inst_arch $inst_path param_array"
          eval $eval_cmd
 
          # apply command to instances in subcomponents 
          if { $COMPONENTS != "" } {
             ApplyToInstances $COMPONENTS $COMMAND param_array $inst_path [expr $LEVEL + 1]
          }
       }
   }
}


# ---------------------- Variable removing ------------------------------
# Remove used variables
proc RemoveVars {VARS} {
   foreach i $VARS {
      if { [info exist $i] } {
         unset $i
      }
   }
}

# ----------------------------------------------------------------------


